"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const command_1 = require("@oclif/command");
const jszip_1 = __importDefault(require("jszip"));
const cli_lib_1 = require("@smartthings/cli-lib");
const package_util_1 = require("../../../lib/commands/drivers/package-util");
const edge_command_1 = require("../../../lib/edge-command");
const channels_1 = require("../channels");
const install_1 = require("./install");
class PackageCommand extends edge_command_1.EdgeCommand {
    async run() {
        const { args, argv, flags } = this.parse(PackageCommand);
        await super.setup(args, argv, flags);
        const uploadAndPostProcess = async (archiveData) => {
            const config = {
                tableFieldDefinitions: ['driverId', 'name', 'packageKey', 'version'],
            };
            const driver = await cli_lib_1.outputItem(this, config, () => this.edgeClient.drivers.upload(archiveData));
            const doAssign = flags.assign || flags.channel || flags.install || flags.hub;
            const doInstall = flags.install || flags.hub;
            if (doAssign) {
                const driverId = driver.driverId;
                const version = driver.version;
                const channelId = await channels_1.chooseChannel(this, 'Select a channel for the driver.', flags.channel);
                await this.edgeClient.channels.assignDriver(channelId, driverId, version);
                if (doInstall) {
                    const hubId = await install_1.chooseHub(this, 'Select a hub to install to.', flags.hub);
                    await this.edgeClient.hubs.installDriver(driverId, hubId, channelId);
                }
            }
        };
        if (flags.upload) {
            try {
                const data = fs_1.default.readFileSync(flags.upload);
                await uploadAndPostProcess(data);
            }
            catch (error) {
                if (error.code === 'ENOENT') {
                    this.log(`No file named "${flags.upload}" found.`);
                }
                else {
                    throw error;
                }
            }
        }
        else {
            const projectDirectory = package_util_1.resolveProjectDirName(this.args.projectDirectory);
            const zip = new jszip_1.default();
            package_util_1.processConfigFile(projectDirectory, zip);
            package_util_1.processFingerprintsFile(projectDirectory, zip);
            const testFileMatchers = package_util_1.buildTestFileMatchers(this.profileConfig.edgeDriverTestDirs);
            package_util_1.processSrcDir(projectDirectory, zip, testFileMatchers);
            package_util_1.processProfiles(projectDirectory, zip);
            if (flags['build-only']) {
                zip.generateNodeStream({ type: 'nodebuffer', streamFiles: true, compression: 'DEFLATE' })
                    .pipe(fs_1.default.createWriteStream(flags['build-only']))
                    .on('finish', () => {
                    this.log(`wrote ${flags['build-only']}`);
                });
            }
            else {
                const zipContents = await zip.generateAsync({ type: 'uint8array', compression: 'DEFLATE' });
                await uploadAndPostProcess(zipContents);
            }
        }
    }
}
exports.default = PackageCommand;
PackageCommand.description = 'build and upload an edge package';
PackageCommand.args = [{
        name: 'projectDirectory',
        description: 'directory containing project to upload',
        default: '.',
    }];
PackageCommand.flags = {
    ...edge_command_1.EdgeCommand.flags,
    ...cli_lib_1.outputItem.flags,
    'build-only': command_1.flags.string({
        char: 'b',
        description: 'save package to specified zip file but skip upload',
        exclusive: ['upload'],
    }),
    upload: command_1.flags.string({
        char: 'u',
        description: 'upload zip file previously built with --build flag',
        exclusive: ['build-only'],
    }),
    assign: command_1.flags.boolean({
        char: 'a',
        description: 'prompt for a channel to assign the driver to after upload',
        exclusive: ['channel', 'build-only'],
    }),
    channel: command_1.flags.string({
        description: 'automatically assign driver to specified channel after upload',
        exclusive: ['assign', 'build-only'],
    }),
    install: command_1.flags.boolean({
        char: 'I',
        description: 'prompt for hub to install to after assigning it to the channel, implies --assign if --assign or --channel not included',
        exclusive: ['hub', 'build-only'],
    }),
    hub: command_1.flags.string({
        description: 'automatically install driver to specified hub, implies --assign if --assign or --channel not included',
        exclusive: ['install', 'build-only'],
    }),
};
PackageCommand.examples = [`# build and upload driver found in current directory:
$ smartthings edge:drivers:package

# build and upload driver found in current directory, assign it to a channel, and install it;
# user will be prompted for channel and hub
$ smartthings edge:drivers:package -I

# build and upload driver found in current directory then assign it to the specified channel
# and install it to the specified hub
$ smartthings edge:drivers:package --channel <channel-id> --hub <hubId>

# build and upload driver found in the my-driver directory
$ smartthings edge:drivers:package my-driver

# build the driver in the my-package directory and save it as driver.zip
$ smartthings edge:drivers:package -b driver.zip my-package

# upload the previously built driver found in driver.zip
$ smartthings edge:drivers:package -u driver.zip`];

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CombinedInputProcessor = exports.userInputProcessor = exports.commandLineInputProcessor = exports.inputProcessor = exports.StdinInputProcessor = exports.FileInputProcessor = exports.inputFlag = exports.commonIOFlags = void 0;
const command_1 = require("@oclif/command");
const io_util_1 = require("./io-util");
// Flags common to both input and output.
exports.commonIOFlags = {
    indent: command_1.flags.integer({
        description: 'specify indentation for formatting JSON or YAML output',
    }),
    json: command_1.flags.boolean({
        description: 'use JSON format of input and/or output',
        char: 'j',
    }),
    yaml: command_1.flags.boolean({
        char: 'y',
        description: 'use YAML format of input and/or output',
    }),
};
exports.inputFlag = {
    input: command_1.flags.string({
        char: 'i',
        description: 'specify input file',
    }),
};
class FileInputProcessor {
    constructor(filename) {
        this.filename = filename;
        this.ioFormat = filename ? io_util_1.formatFromFilename(filename) : io_util_1.IOFormat.JSON;
    }
    hasInput() {
        return !!this.filename;
    }
    async read() {
        if (!this.filename) {
            throw ReferenceError('read called when hasInput returns false');
        }
        return io_util_1.parseJSONOrYAML(await io_util_1.readFile(this.filename, 'utf-8'), this.filename);
    }
}
exports.FileInputProcessor = FileInputProcessor;
class StdinInputProcessor {
    constructor() {
        // Could be JSON or YAML but it's not really worth trying to figure out which.
        this.ioFormat = io_util_1.IOFormat.JSON;
    }
    hasInput() {
        return !io_util_1.stdinIsTTY();
    }
    async read() {
        return io_util_1.parseJSONOrYAML(await io_util_1.readDataFromStdin(), 'stdin');
    }
}
exports.StdinInputProcessor = StdinInputProcessor;
/**
 * Build an input processor given the necessary functions for doing so.
 */
function inputProcessor(hasInput, read, ioFormat = io_util_1.IOFormat.COMMON) {
    return { ioFormat, hasInput, read };
}
exports.inputProcessor = inputProcessor;
/**
 * Shortcut for building an InputProcessor that can build complex input from the command line
 * arguments using standard methods in `command` defined in `CommandLineInputCommand`.
 */
function commandLineInputProcessor(command) {
    return inputProcessor(() => command.hasCommandLineInput(), () => command.getInputFromCommandLine());
}
exports.commandLineInputProcessor = commandLineInputProcessor;
/**
 * Shortcut for building an InputProcessor that queries the user for complex input using a
 * Q & A session using standard methods in `command` defined in `UserInputCommand`. This should
 * always be the last one in the list since input processors are checked in order and this can
 * always provide data.
 */
function userInputProcessor(command) {
    return inputProcessor(() => true, () => command.getInputFromUser());
}
exports.userInputProcessor = userInputProcessor;
class CombinedInputProcessor {
    constructor(inputProcessor, ...inputProcessors) {
        this.inputProcessors = [inputProcessor, ...inputProcessors];
    }
    get ioFormat() {
        if (!this._ioFormat) {
            throw new ReferenceError('ioFormat called before read');
        }
        return this._ioFormat;
    }
    hasInput() {
        this.theInputProcessor = this.inputProcessors.find(ip => ip.hasInput());
        return !!this.theInputProcessor;
    }
    async read() {
        if (!this.theInputProcessor) {
            throw ReferenceError('read called when hasInput returns false');
        }
        const retVal = this.theInputProcessor.read();
        this._ioFormat = this.theInputProcessor.ioFormat;
        return retVal;
    }
}
exports.CombinedInputProcessor = CombinedInputProcessor;

import { flags } from '@oclif/command';
import { IOFormat } from './io-util';
export declare const commonIOFlags: {
    indent: import("@oclif/parser/lib/flags").IOptionFlag<number | undefined>;
    json: import("@oclif/parser/lib/flags").IBooleanFlag<boolean>;
    yaml: import("@oclif/parser/lib/flags").IBooleanFlag<boolean>;
};
export declare const inputFlag: {
    input: flags.IOptionFlag<string | undefined>;
};
export interface InputProcessor<T> {
    /**
     * Return the type of input this processor retrieved. This should not be called until after
     * data has been read via `read` so throwing an exception before that is acceptable.
     */
    readonly ioFormat: IOFormat;
    /**
     * This is called before calling `read` to determine if there is input from this processor.
     * The processor should return `false` to indicate `read` should not be called or `true`
     * if calling `read` can be expected to return data.
     */
    hasInput(): boolean;
    /**
     * Actually read the input. This should not be called if `hasInput` returned false and should
     * ensure further calls to `ioFormat` return appropriate data.
     */
    read(): Promise<T>;
}
export declare class FileInputProcessor<T> implements InputProcessor<T> {
    private readonly filename?;
    readonly ioFormat: IOFormat;
    constructor(filename?: string | undefined);
    hasInput(): boolean;
    read(): Promise<T>;
}
export declare class StdinInputProcessor<T> implements InputProcessor<T> {
    readonly ioFormat = IOFormat.JSON;
    hasInput(): boolean;
    read(): Promise<T>;
}
/**
 * Build an input processor given the necessary functions for doing so.
 */
export declare function inputProcessor<T>(hasInput: () => boolean, read: () => Promise<T>, ioFormat?: IOFormat): InputProcessor<T>;
export interface CommandLineInputCommand<T> {
    hasCommandLineInput(): boolean;
    getInputFromCommandLine(): Promise<T>;
}
/**
 * Shortcut for building an InputProcessor that can build complex input from the command line
 * arguments using standard methods in `command` defined in `CommandLineInputCommand`.
 */
export declare function commandLineInputProcessor<T>(command: CommandLineInputCommand<T>): InputProcessor<T>;
export interface UserInputCommand<T> {
    getInputFromUser(): Promise<T>;
}
/**
 * Shortcut for building an InputProcessor that queries the user for complex input using a
 * Q & A session using standard methods in `command` defined in `UserInputCommand`. This should
 * always be the last one in the list since input processors are checked in order and this can
 * always provide data.
 */
export declare function userInputProcessor<T>(command: UserInputCommand<T>): InputProcessor<T>;
export declare class CombinedInputProcessor<T> implements InputProcessor<T> {
    private inputProcessors;
    private theInputProcessor?;
    private _ioFormat?;
    get ioFormat(): IOFormat;
    constructor(inputProcessor: InputProcessor<T>, ...inputProcessors: InputProcessor<T>[]);
    hasInput(): boolean;
    read(): Promise<T>;
}

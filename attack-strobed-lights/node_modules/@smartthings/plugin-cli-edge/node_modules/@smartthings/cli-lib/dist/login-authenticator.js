"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoginAuthenticator = exports.defaultClientIdProvider = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const crypto_1 = require("crypto");
const express_1 = tslib_1.__importDefault(require("express"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const get_port_1 = tslib_1.__importDefault(require("get-port"));
const open_1 = tslib_1.__importDefault(require("open"));
const path_1 = tslib_1.__importDefault(require("path"));
const qs_1 = tslib_1.__importDefault(require("qs"));
const core_sdk_1 = require("@smartthings/core-sdk");
const logger_1 = require("./logger");
exports.defaultClientIdProvider = {
    ...core_sdk_1.defaultSmartThingsURLProvider,
    baseOAuthInURL: 'https://oauthin-regional.api.smartthings.com/oauth',
    oauthAuthTokenRefreshURL: 'https://auth-global.api.smartthings.com/oauth/token',
    clientId: 'd18cf96e-c626-4433-bf51-ddbb10c5d1ed',
};
// All the scopes the clientId we are using is configured to use.
const scopes = ['controller%3AstCli'];
const postConfig = {
    headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
    },
};
function credentialsFile() {
    if (!('_credentialsFile' in global)) {
        throw new Error('LoginAuthenticator credentials file not set.');
    }
    return global._credentialsFile;
}
class LoginAuthenticator {
    constructor(profileName, clientIdProvider) {
        this.profileName = profileName;
        this.clientIdProvider = clientIdProvider;
        this.logger = logger_1.logManager.getLogger('login-authenticator');
        this.logger.trace('constructing a LoginAuthenticator');
        this.clientId = clientIdProvider.clientId;
        // we could consider doing this lazily at some point
        const credentialsFileData = this.readCredentialsFile();
        if (profileName in credentialsFileData) {
            const authInfo = credentialsFileData[profileName];
            this.authenticationInfo = {
                ...authInfo,
                expires: new Date(authInfo.expires),
            };
            this.logger.trace(`authentication info from file = ${JSON.stringify(this.authenticationInfo, null, 4)}`);
        }
    }
    static init(credentialsFile) {
        global._credentialsFile = credentialsFile;
        const cliDir = path_1.default.dirname(credentialsFile);
        fs_1.default.mkdirSync(cliDir, { recursive: true });
    }
    base64URLEncode(data) {
        return data.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
    }
    sha256(data) {
        return crypto_1.createHash('sha256').update(data).digest();
    }
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    readCredentialsFile() {
        let fileData = '{}';
        try {
            fileData = fs_1.default.readFileSync(credentialsFile()).toString();
        }
        catch (err) {
            if (err.code !== 'ENOENT') {
                throw err;
            }
        }
        return JSON.parse(fileData);
    }
    writeCredentialsFile(credentialsFileData) {
        fs_1.default.writeFileSync(credentialsFile(), JSON.stringify(credentialsFileData, null, 4));
        fs_1.default.chmod(credentialsFile(), 0o600, err => {
            if (err) {
                this.logger.error('failed to set permissions on credentials file', err);
            }
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    updateTokenFromResponse(response) {
        const authenticationInfo = {
            accessToken: response.data.access_token,
            refreshToken: response.data.refresh_token,
            expires: new Date(Date.now() + response.data.expires_in * 1000),
            scope: response.data.scope,
            installedAppId: response.data.installed_app_id,
            deviceId: response.data.device_id,
        };
        const credentialsFileData = this.readCredentialsFile();
        credentialsFileData[this.profileName] = authenticationInfo;
        this.writeCredentialsFile(credentialsFileData);
        this.authenticationInfo = authenticationInfo;
    }
    async login() {
        const verifier = this.base64URLEncode(crypto_1.randomBytes(32));
        const app = express_1.default();
        const port = await get_port_1.default({ port: [61973, 61974, 61975] });
        const baseOAuthInURL = this.clientIdProvider.baseOAuthInURL;
        const codeChallenge = this.base64URLEncode(this.sha256(verifier));
        const finishURL = `http://localhost:${port}/finish`;
        let loginFailed = false;
        app.get('/start', (req, res) => {
            const redirectTo = `${baseOAuthInURL}/authorize?scope=${scopes.join('+')}&` +
                `response_type=code&client_id=${this.clientId}&` +
                `code_challenge=${codeChallenge}&code_challenge_method=S256&` +
                `redirect_uri=${encodeURIComponent(finishURL)}&` +
                'client_type=USER_LEVEL';
            this.logger.trace(`redirecting to: ${redirectTo}`);
            res.redirect(redirectTo);
        });
        app.get('/finish', (req, res) => {
            if ('error' in req.query) {
                this.logger.error(`received "${req.query.error}" error when trying to authenticate`);
                if ('error_description' in req.query) {
                    this.logger.error(`  ${req.query.error_description}`);
                }
                loginFailed = true;
                res.send('<html><body><h1>Failure trying to authenticate.</h1></body></html>');
                return;
            }
            const requestBody = {
                'grant_type': 'authorization_code',
                'client_id': this.clientId,
                'code_verifier': verifier,
                'code': req.query.code,
                'redirect_uri': finishURL,
            };
            this.logger.trace(`making axios request to ${baseOAuthInURL}/token with:`);
            this.logger.trace(`  body: ${qs_1.default.stringify(requestBody)}`);
            this.logger.trace(`  config: ${JSON.stringify(postConfig)}`);
            this.logger.trace(`code = ${req.query.code}`);
            // I used this for debugging. Axios does not include the body of the response in any way I could find.
            // this.logger.trace(`\n\nRun:\ncurl -i --request POST --url '${baseOAuthInURL}/token' --header 'content-type: application/x-www-form-urlencoded' ` +
            // 	`--data grant_type=authorization_code --data 'client_id=${this.clientId}' --data code_verifier=${verifier} --data code=${req.query.code} ` +
            // 	`--data 'redirect_uri=${finishURL}' --header 'X-ST-CORRELATION: ross-pkce-attempt'\n\n`)
            axios_1.default.post(`${baseOAuthInURL}/token`, qs_1.default.stringify(requestBody), postConfig)
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                .then((response) => {
                this.updateTokenFromResponse(response);
                res.send('<html><body><h1>You can close the window.</h1></body></html>');
            })
                .catch(err => {
                this.logger.trace(`got error ${err.name}/${err}}/${err.message} trying to get final token`);
                this.logger.trace(`err = ${JSON.stringify(err, null, 4)}`);
                loginFailed = true;
                res.send('<html><body><h1>Failure trying retrieve token.</h1></body></html>');
            });
        });
        const server = app.listen(port, async () => {
            this.logger.trace(`listening on port ${port}`);
            await open_1.default(`http://localhost:${port}/start`);
        });
        const startTime = Date.now();
        const maxDelay = 10 * 60 * 1000; // wait up to ten minutes for login
        this.authenticationInfo = undefined;
        // eslint-disable-next-line no-async-promise-executor
        return new Promise(async (resolve, reject) => {
            while (!loginFailed && !this.authenticationInfo && Date.now() < startTime + maxDelay) {
                process.stderr.write('.');
                await this.delay(1000);
            }
            server.close(err => {
                if (err) {
                    this.logger.error(`error closing express server: ${err}`);
                }
                if (this.authenticationInfo) {
                    this.logger.trace(`got authentication info: ${JSON.stringify(this.authenticationInfo)}`);
                    resolve();
                }
                else {
                    this.logger.trace('unable to get authentication info');
                    reject('unable to get authentication info');
                }
            });
        });
    }
    async logout() {
        const credentialsFileData = this.readCredentialsFile();
        delete credentialsFileData[this.profileName];
        this.writeCredentialsFile(credentialsFileData);
    }
    async refreshToken() {
        var _a;
        this.logger.trace('refreshing token');
        const oauthAuthTokenRefreshURL = this.clientIdProvider.oauthAuthTokenRefreshURL;
        const requestBody = {
            'grant_type': 'refresh_token',
            'client_id': this.clientId,
            'refresh_token': (_a = this.authenticationInfo) === null || _a === void 0 ? void 0 : _a.refreshToken,
        };
        const postConfig = {
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
        };
        this.logger.trace(`making axios request to ${oauthAuthTokenRefreshURL} with:`);
        this.logger.trace(`  body: ${qs_1.default.stringify(requestBody)}`);
        this.logger.trace(`  config: ${JSON.stringify(postConfig)}`);
        await axios_1.default.post(oauthAuthTokenRefreshURL, qs_1.default.stringify(requestBody), postConfig)
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            .then((response) => {
            this.updateTokenFromResponse(response);
        })
            .catch(err => {
            this.logger.trace(`got error ${err.name}/${err}}/${err.message} trying to get refresh token`);
            this.logger.trace(`err = ${JSON.stringify(err, null, 4)}`);
        });
    }
    async authenticate(requestConfig) {
        const token = await this.authenticateGeneric();
        return {
            ...requestConfig,
            headers: {
                ...requestConfig.headers,
                Authorization: `Bearer ${token}`,
            },
        };
    }
    async authenticateGeneric() {
        this.logger.trace('authentication - enter');
        // refresh if we have less than an hour left on the auth token
        if (this.authenticationInfo && this.authenticationInfo.expires.getTime() < Date.now() + 60 * 60 * 1000) {
            await this.refreshToken();
        }
        // log in if we don't have authentication info or the refresh failed
        if (!this.authenticationInfo || this.authenticationInfo.expires.getTime() < Date.now() + 59 * 60 * 1000) {
            await this.login();
        }
        if (this.authenticationInfo) {
            return this.authenticationInfo.accessToken;
        }
        throw new Error('unable to obtain user credentials');
    }
}
exports.LoginAuthenticator = LoginAuthenticator;

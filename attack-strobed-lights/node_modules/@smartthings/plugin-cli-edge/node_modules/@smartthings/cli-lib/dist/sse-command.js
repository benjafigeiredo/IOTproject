"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SseCommand = void 0;
const tslib_1 = require("tslib");
const api_command_1 = require("./api-command");
const sse_util_1 = require("./sse-util");
const eventsource_1 = tslib_1.__importDefault(require("eventsource"));
const errors_1 = require("@oclif/errors");
class SseCommand extends api_command_1.APICommand {
    get source() {
        if (this._source) {
            return this._source;
        }
        throw new Error('SseCommand not initialized properly');
    }
    async initSource(url, sourceInitDict) {
        // assume auth is taken care of if passing an initDict
        if (!sourceInitDict && this.authenticator.authenticateGeneric) {
            const token = await this.authenticator.authenticateGeneric();
            sourceInitDict = { headers: { 'Authorization': `Bearer ${token}` } };
        }
        this._source = new eventsource_1.default(url, sourceInitDict);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this._source.onerror = (error) => {
            try {
                let message;
                if (error) {
                    if (error.status) {
                        if (error.status === 401 || error.status === 403) {
                            message = `Event source not authorized. ${error.message}`;
                        }
                        else {
                            message = `Event source error ${error.status}. ${error.message}`;
                        }
                    }
                    else {
                        message = `Event source error. ${error.message}`;
                    }
                }
                else {
                    message = 'Unexpected event source error.';
                }
                this.teardown();
                this.error(message);
            }
            catch (error) {
                errors_1.handle(error);
            }
        };
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async setup(args, argv, flags) {
        await super.setup(args, argv, flags);
    }
    teardown() {
        var _a, _b;
        try {
            (_a = this._source) === null || _a === void 0 ? void 0 : _a.close();
        }
        catch (error) {
            this.logger.warn(`Error during SseCommand cleanup. ${(_b = error.message) !== null && _b !== void 0 ? _b : error}`);
        }
    }
    async init() {
        sse_util_1.handleSignals(() => {
            this.teardown();
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async catch(error) {
        this.teardown();
        throw error;
    }
}
exports.SseCommand = SseCommand;
SseCommand.flags = api_command_1.APICommand.flags;

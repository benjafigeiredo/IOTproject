"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.chooseApp = exports.tableFieldDefinitions = void 0;
const command_1 = require("@oclif/command");
const core_sdk_1 = require("@smartthings/core-sdk");
const cli_lib_1 = require("@smartthings/cli-lib");
const isWebhookSmartApp = (app) => !!app.webhookSmartApp;
const hasSubscription = (app) => { var _a; return !!((_a = app.apiOnly) === null || _a === void 0 ? void 0 : _a.subscription); };
exports.tableFieldDefinitions = [
    'displayName',
    'appId',
    'appName',
    'description',
    'singleInstance',
    { prop: 'classifications', include: app => !!app.classifications },
    { prop: 'installMetadata.certified', include: app => { var _a; return !!((_a = app.installMetadata) === null || _a === void 0 ? void 0 : _a.certified); } },
    { prop: 'installMetadata.maxInstalls', include: app => { var _a; return !!((_a = app.installMetadata) === null || _a === void 0 ? void 0 : _a.maxInstalls); } },
    'appType',
    { prop: 'webhookSmartApp.signatureType', include: isWebhookSmartApp },
    { prop: 'webhookSmartApp.targetUrl', include: isWebhookSmartApp },
    { prop: 'webhookSmartApp.targetStatus', include: isWebhookSmartApp },
    {
        prop: 'webhookSmartApp.publicKey',
        include: app => { var _a; return !!((_a = app.webhookSmartApp) === null || _a === void 0 ? void 0 : _a.publicKey); },
        value: app => { var _a, _b, _c; return (_c = (_b = (_a = app.webhookSmartApp) === null || _a === void 0 ? void 0 : _a.publicKey) === null || _b === void 0 ? void 0 : _b.replace(/\r\n/g, '\n')) !== null && _c !== void 0 ? _c : ''; },
    },
    {
        include: app => { var _a; return !!((_a = app.lambdaSmartApp) === null || _a === void 0 ? void 0 : _a.functions); },
        label: 'Lambda Function',
        value: app => { var _a, _b, _c; return (_c = (_b = (_a = app.lambdaSmartApp) === null || _a === void 0 ? void 0 : _a.functions) === null || _b === void 0 ? void 0 : _b.join('\n')) !== null && _c !== void 0 ? _c : ''; },
    },
    { prop: 'apiOnly.subscription.targetUrl', include: hasSubscription },
    { prop: 'apiOnly.subscription.targetStatus', include: hasSubscription },
    { prop: 'installMetadata.certified', include: app => { var _a; return ((_a = app.installMetadata) === null || _a === void 0 ? void 0 : _a.certified) !== undefined; } },
];
async function chooseApp(command, appFromArg, options) {
    const opts = cli_lib_1.chooseOptionsWithDefaults(options);
    const config = {
        itemName: 'app',
        primaryKeyName: 'appId',
        sortKeyName: 'displayName',
    };
    const listApps = () => command.client.apps.list();
    const preselectedId = opts.allowIndex
        ? await cli_lib_1.stringTranslateToId(config, appFromArg, listApps)
        : appFromArg;
    return cli_lib_1.selectFromList(command, config, preselectedId, listApps);
}
exports.chooseApp = chooseApp;
class AppsCommand extends cli_lib_1.APICommand {
    async run() {
        const { args, argv, flags } = this.parse(AppsCommand);
        await super.setup(args, argv, flags);
        const config = {
            primaryKeyName: 'appId',
            sortKeyName: 'displayName',
            tableFieldDefinitions: exports.tableFieldDefinitions,
            listTableFieldDefinitions: ['displayName', 'appType', 'appId'],
        };
        if (flags.verbose) {
            config.listTableFieldDefinitions.push('ARN/URL');
        }
        const listApps = async () => {
            const appListOptions = {};
            if (flags.type) {
                appListOptions.appType = core_sdk_1.AppType[flags.type];
            }
            if (flags.classification) {
                appListOptions.classification = flags.classification.map(it => core_sdk_1.AppClassification[it]);
            }
            // TODO -- uncomment when implemented
            // if (flags.tag) {
            // 	appListOptions.tag = flags.tag.reduce((map: {[key: string]: string}, it) => {
            // 		const pos = it.indexOf(':')
            // 		map[it.slice(0, pos)] = it.slice(pos+1)
            // 		return map
            // 	}, {})
            // }
            if (flags.verbose) {
                return this.client.apps.list(appListOptions).then(list => {
                    const objects = list.map(it => {
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        return this.client.apps.get((it.appId)); // TODO appId should not be optional
                    });
                    return Promise.all(objects).then((list) => {
                        var _a, _b, _c, _d, _e, _f, _g;
                        for (const item of list) {
                            const uri = (_g = (item.webhookSmartApp ?
                                item.webhookSmartApp.targetUrl :
                                (item.lambdaSmartApp ? (((_b = (_a = item.lambdaSmartApp) === null || _a === void 0 ? void 0 : _a.functions) === null || _b === void 0 ? void 0 : _b.length) ? (_c = item.lambdaSmartApp) === null || _c === void 0 ? void 0 : _c.functions[0] : '') :
                                    ((_f = (_e = (_d = item.apiOnly) === null || _d === void 0 ? void 0 : _d.subscription) === null || _e === void 0 ? void 0 : _e.targetUrl) !== null && _f !== void 0 ? _f : '')))) !== null && _g !== void 0 ? _g : '';
                            const arnURL = uri.length < 96 ? uri : uri.slice(0, 95) + '...';
                            item['ARN/URL'] = arnURL;
                        }
                        return list;
                    });
                });
            }
            return this.client.apps.list(appListOptions);
        };
        await cli_lib_1.outputListing(this, config, args.id, listApps, id => this.client.apps.get(id));
    }
}
exports.default = AppsCommand;
AppsCommand.description = 'get a specific app or a list of apps';
AppsCommand.flags = {
    ...cli_lib_1.APICommand.flags,
    ...cli_lib_1.outputListing.flags,
    type: command_1.flags.string({
        description: 'filter results by appType, WEBHOOK_SMART_APP, LAMBDA_SMART_APP, API_ONLY',
        multiple: false,
    }),
    classification: command_1.flags.string({
        description: 'filter results by one or more classifications, AUTOMATION, SERVICE, DEVICE, CONNECTED_SERVICE',
        multiple: true,
    }),
    // TODO -- uncomment when implemented
    // tag: flags.string({
    // 	description: 'filter results by one or more tags, e.g. --tag=industry:energy',
    // 	multiple: true,
    // }),
    verbose: command_1.flags.boolean({
        description: 'include URLs and ARNs in table output',
        char: 'v',
    }),
};
AppsCommand.args = [{
        name: 'id',
        description: 'the app id or number from list',
    }];

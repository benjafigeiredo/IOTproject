import { flags } from '@oclif/command';
import { CommonListOutputProducer, CommonOutputProducer } from './format';
import { InputProcessor } from './input';
import { IOFormat } from './io-util';
import { SmartThingsCommandInterface } from './smartthings-command';
export declare type GetDataFunction<O> = () => Promise<O>;
export declare type ListDataFunction<L> = () => Promise<L[]>;
export declare type LookupDataFunction<ID, O> = (id: ID) => Promise<O>;
export declare type ActionFunction<ID, I, O> = (id: ID, input: I) => Promise<O>;
export declare type IdTranslationFunction<ID, L> = (idOrIndex: ID | string, listFunction: ListDataFunction<L>) => Promise<ID>;
export declare type IdRetrievalFunction<ID, L> = (fieldInfo: Sorting, list: L[], promptMessage?: string) => Promise<ID>;
/**
 * This interface is used when a list is presented to the user, especially when they will have the
 * opportunity to select an item from the list.
 *
 * The primary (but not only) example of this the list/get versions of commands. Consider the
 * simple `locations` command. When specified without an id or index, it needs to present the
 * results in a consistent order. If the user specifies an index into that list when querying
 * a single location, the sort key specified here is used again to ensure the same ordering.
 */
export interface Sorting {
    /**
     * The primary key used to uniquely identify this object.
     */
    primaryKeyName: string;
    /**
     * The field you want to sort by when presenting a list of items.
     */
    sortKeyName: string;
}
/**
 * This interface is used in configurations to help describe a named item.
 *
 * If you're writing code that uses this interface, use `itemName` or `pluralItemName` from
 * command-util to translate a `Naming` instance to a name.
 */
export interface Naming {
    /**
     * The singular name of your item, using lowercase letters and spaces to separate words.
     */
    itemName?: string;
    /**
     * You only need to specify the plural version of your name if adding a simple "s" is incorrect.
     */
    pluralItemName?: string;
}
export declare function inputItem<I>(command: SmartThingsCommandInterface, ...alternateInputProcessors: InputProcessor<I>[]): Promise<[I, IOFormat]>;
export declare namespace inputItem {
    var flags: {
        input: flags.IOptionFlag<string | undefined>;
        indent: import("@oclif/parser/lib/flags").IOptionFlag<number | undefined>;
        json: import("@oclif/parser/lib/flags").IBooleanFlag<boolean>;
        yaml: import("@oclif/parser/lib/flags").IBooleanFlag<boolean>;
    };
}
export declare function outputItem<O>(command: SmartThingsCommandInterface, config: CommonOutputProducer<O>, getData: GetDataFunction<O>): Promise<O>;
export declare namespace outputItem {
    var flags: {
        output: flags.IOptionFlag<string | undefined>;
        compact: import("@oclif/parser/lib/flags").IBooleanFlag<boolean>;
        expanded: import("@oclif/parser/lib/flags").IBooleanFlag<boolean>;
        indent: import("@oclif/parser/lib/flags").IOptionFlag<number | undefined>;
        json: import("@oclif/parser/lib/flags").IBooleanFlag<boolean>;
        yaml: import("@oclif/parser/lib/flags").IBooleanFlag<boolean>;
    };
}
export declare function outputList<L>(command: SmartThingsCommandInterface, config: CommonListOutputProducer<L> & Sorting, getData: GetDataFunction<L[]>, includeIndex?: boolean, forUserQuery?: boolean): Promise<L[]>;
export declare namespace outputList {
    var flags: {
        output: flags.IOptionFlag<string | undefined>;
        compact: import("@oclif/parser/lib/flags").IBooleanFlag<boolean>;
        expanded: import("@oclif/parser/lib/flags").IBooleanFlag<boolean>;
        indent: import("@oclif/parser/lib/flags").IOptionFlag<number | undefined>;
        json: import("@oclif/parser/lib/flags").IBooleanFlag<boolean>;
        yaml: import("@oclif/parser/lib/flags").IBooleanFlag<boolean>;
    };
}
export declare function inputAndOutputItem<I, O>(command: SmartThingsCommandInterface, config: CommonOutputProducer<O>, executeAction: ActionFunction<void, I, O>, ...alternateInputProcessors: InputProcessor<I>[]): Promise<void>;
export declare namespace inputAndOutputItem {
    var flags: {
        'dry-run': import("@oclif/parser/lib/flags").IBooleanFlag<boolean>;
        output: flags.IOptionFlag<string | undefined>;
        compact: import("@oclif/parser/lib/flags").IBooleanFlag<boolean>;
        expanded: import("@oclif/parser/lib/flags").IBooleanFlag<boolean>;
        indent: import("@oclif/parser/lib/flags").IOptionFlag<number | undefined>;
        json: import("@oclif/parser/lib/flags").IBooleanFlag<boolean>;
        yaml: import("@oclif/parser/lib/flags").IBooleanFlag<boolean>;
        input: flags.IOptionFlag<string | undefined>;
    };
}

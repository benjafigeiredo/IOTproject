"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultTableGenerator = void 0;
const tslib_1 = require("tslib");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const cli_table_1 = tslib_1.__importDefault(require("cli-table"));
const logger_1 = require("./logger");
class DefaultTableGenerator {
    constructor(compact) {
        this.compact = compact;
    }
    get logger() {
        if (!this._logger) {
            this._logger = logger_1.logManager.getLogger('table-manager');
        }
        return this._logger;
    }
    convertToLabel(propertyName) {
        // We only use the last field for the name if it's a nested property.
        const propertyNames = propertyName.split('.');
        return propertyNames[propertyNames.length - 1]
            .replace(/([a-z])([A-Z])/g, '$1 $2')
            .replace(/^([a-z])/, text => text.toUpperCase())
            .replace(/\bUri\b/, 'URI')
            .replace(/\bUrl\b/, 'URL')
            .replace(/\bArn\b/, 'ARN')
            .replace(/\bO ?[Aa]uth\b/, 'OAuth')
            .replace(/^Is /, '');
    }
    getLabelFor(definition) {
        if (typeof definition === 'string') {
            return this.convertToLabel(definition);
        }
        if (definition.label) {
            return definition.label;
        }
        if (!definition.prop) {
            throw Error('both label and value are required if prop is not specified');
        }
        return this.convertToLabel(definition.prop);
    }
    getDisplayValueFor(item, definition) {
        var _a;
        if (!(typeof definition === 'string') && definition.value) {
            return (_a = definition.value(item)) !== null && _a !== void 0 ? _a : '';
        }
        const propertyName = typeof definition === 'string' ? definition : definition.prop;
        if (!propertyName) {
            throw Error('both label and value are required if prop is not specified');
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        const matches = lodash_1.default.at(item, propertyName);
        if (matches.length === 0) {
            this.logger.debug(`did not find match for ${propertyName} in ${JSON.stringify(item)}`);
            return '';
        }
        if (matches.length > 1) {
            this.logger.warn(`found more than one match for ${propertyName} in ${JSON.stringify(item)}`);
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return matches.map((value) => value ? value.toString() : '').join(', ');
    }
    newOutputTable(options) {
        const configuredOptions = { style: { compact: this.compact } };
        if (options) {
            return new cli_table_1.default({ ...configuredOptions, ...options });
        }
        return new cli_table_1.default(configuredOptions);
    }
    buildTableFromItem(item, definitions) {
        const table = this.newOutputTable();
        for (const definition of definitions) {
            if (typeof definition === 'string'
                || definition.include === undefined
                || definition.include(item)) {
                const value = this.getDisplayValueFor(item, definition);
                if (typeof definition === 'string'
                    || !definition.skipEmpty
                    || value) {
                    table.push([this.getLabelFor(definition), value]);
                }
            }
        }
        return table.toString();
    }
    buildTableFromList(items, definitions) {
        const headingLabels = definitions.map(def => this.getLabelFor(def));
        const table = this.newOutputTable({ head: headingLabels });
        for (const item of items) {
            table.push(definitions.map(def => this.getDisplayValueFor(item, def)));
        }
        return table.toString();
    }
}
exports.DefaultTableGenerator = DefaultTableGenerator;

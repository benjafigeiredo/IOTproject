"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.logManager = exports.loadLoggingConfig = exports.defaultLoggingConfig = exports.LogManager = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const js_yaml_1 = tslib_1.__importDefault(require("js-yaml"));
const log4js_1 = require("log4js");
const DEFAULT_LOG_FILE_SIZE = 1000000; // bytes
const LOGGING_DOCS_URL = 'https://github.com/SmartThingsCommunity/smartthings-cli/' +
    'blob/master/packages/cli/doc/configuration.md#logging';
class Log4JSLogger {
    constructor(logger) {
        this.logger = logger;
    }
    get level() {
        // The types are defined for log4js don't match up with the reality
        // of what it's returning.
        return this.logger.level.levelStr;
    }
    set level(level) {
        this.logger.level = level;
    }
    /* eslint-disable @typescript-eslint/no-explicit-any */
    trace(message, ...args) {
        this.logger.trace(message, ...args);
    }
    debug(message, ...args) {
        this.logger.debug(message, ...args);
    }
    info(message, ...args) {
        this.logger.info(message, ...args);
    }
    warn(message, ...args) {
        this.logger.warn(message, ...args);
    }
    error(message, ...args) {
        this.logger.error(message, ...args);
    }
    fatal(message, ...args) {
        this.logger.fatal(message, ...args);
    }
    /* eslint-enable */
    isTraceEnabled() {
        return this.logger.isTraceEnabled();
    }
    isDebugEnabled() {
        return this.logger.isDebugEnabled();
    }
    isInfoEnabled() {
        return this.logger.isInfoEnabled();
    }
    isWarnEnabled() {
        return this.logger.isWarnEnabled();
    }
    isErrorEnabled() {
        return this.logger.isErrorEnabled();
    }
    isFatalEnabled() {
        return this.logger.isFatalEnabled();
    }
}
class LogManager {
    constructor() {
        this.loggersByName = {};
    }
    init(config) {
        this.getLog4jsLogger = log4js_1.configure(config).getLogger;
    }
    getLogger(name) {
        if (!this.getLog4jsLogger) {
            throw new Error('logging not initialized');
        }
        if (name in this.loggersByName) {
            return this.loggersByName[name];
        }
        const logger = new Log4JSLogger(this.getLog4jsLogger(name));
        this.loggersByName[name] = logger;
        return logger;
    }
}
exports.LogManager = LogManager;
function defaultLoggingConfig(logFilename) {
    return {
        appenders: {
            smartthings: { type: 'file', filename: logFilename, maxLogSize: DEFAULT_LOG_FILE_SIZE },
            stderr: { type: 'stderr' },
            errors: { type: 'logLevelFilter', appender: 'stderr', level: 'error' },
        },
        categories: {
            default: { appenders: ['smartthings', 'errors'], level: 'warn' },
            'rest-client': { appenders: ['smartthings', 'errors'], level: 'warn' },
            cli: { appenders: ['smartthings', 'errors'], level: 'warn' },
        },
    };
}
exports.defaultLoggingConfig = defaultLoggingConfig;
function loadLoggingConfig(configFilename, defaultConfig) {
    if (!fs_1.default.existsSync(configFilename)) {
        return defaultConfig;
    }
    const parsed = js_yaml_1.default.safeLoad(fs_1.default.readFileSync(configFilename, 'utf-8'));
    if (parsed && typeof parsed === 'object') {
        return parsed;
    }
    throw new Error(`invalid or unreadable logging config file format; see ${LOGGING_DOCS_URL}`);
}
exports.loadLoggingConfig = loadLoggingConfig;
if (!('_logManager' in global)) {
    global._logManager = new LogManager();
}
exports.logManager = global._logManager;

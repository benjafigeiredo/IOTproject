"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatAndWriteList = exports.formatAndWriteItem = void 0;
const output_1 = require("./output");
const output_builder_1 = require("./output-builder");
/**
 * Format and output the given item.
 *
 * @param command The command outputting the list.
 * @param config Configuration for how to write the list. This must include either a list of
 *   table field definitions called `tableFieldDefinitions` or a function to write common-formatted
 *   output called `buildTableOutput`.
 * @param item The item to be written.
 * @param defaultIOFormat The default IOFormat to use. This should be used when a command also takes
 *   input so the output can default to the input format.
 */
async function formatAndWriteItem(command, config, item, defaultIOFormat) {
    const commonFormatter = 'buildTableOutput' in config
        ? (data) => config.buildTableOutput(data)
        : output_1.itemTableFormatter(command.tableGenerator, config.tableFieldDefinitions);
    const outputFormatter = output_builder_1.buildOutputFormatter(command, defaultIOFormat, commonFormatter);
    await output_1.writeOutput(outputFormatter(item), command.flags.output);
}
exports.formatAndWriteItem = formatAndWriteItem;
formatAndWriteItem.flags = output_builder_1.buildOutputFormatter.flags;
/**
 * Format and output the given list.
 *
 * @param command The command outputting the list.
 * @param config Configuration for how to write the list. This must include either a list of
 *   table field definitions called `listTableFieldDefinitions` or a function to write
 *   common-formatted output called `buildTableOutput`.
 * @param list The items to be written.
 * @param includeIndex Set this to true if you want to include an index in the output.
 * @param forUserQuery Set this to true if you're displaying this to the user for a question. This
 *   will force output to stdout and skip the JSON/YAML formatters.
 */
async function formatAndWriteList(command, config, list, includeIndex = false, forUserQuery = false) {
    var _a;
    let commonFormatter;
    if (list.length === 0) {
        const pluralName = (_a = config.pluralItemName) !== null && _a !== void 0 ? _a : (config.itemName ? `${config.itemName}s` : 'items');
        commonFormatter = () => `no ${pluralName} found`;
    }
    else if ('buildListTableOutput' in config) {
        commonFormatter = data => config.buildListTableOutput(data);
    }
    else if ('listTableFieldDefinitions' in config) {
        commonFormatter = output_1.listTableFormatter(command.tableGenerator, config.listTableFieldDefinitions, includeIndex);
    }
    else {
        commonFormatter = output_1.listTableFormatter(command.tableGenerator, [config.sortKeyName, config.primaryKeyName], includeIndex);
    }
    const outputFormatter = forUserQuery ? commonFormatter : output_builder_1.buildOutputFormatter(command, undefined, commonFormatter);
    await output_1.writeOutput(outputFormatter(list), forUserQuery ? undefined : command.flags.output);
}
exports.formatAndWriteList = formatAndWriteList;

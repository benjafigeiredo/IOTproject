"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stdoutIsTTY = exports.stdinIsTTY = exports.readDataFromStdin = exports.parseJSONOrYAML = exports.formatFromFilename = exports.IOFormat = exports.writeFile = exports.readFile = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const util_1 = tslib_1.__importDefault(require("util"));
const js_yaml_1 = tslib_1.__importDefault(require("js-yaml"));
const logger_1 = require("./logger");
exports.readFile = util_1.default.promisify(fs_1.default.readFile);
exports.writeFile = util_1.default.promisify(fs_1.default.writeFile);
var IOFormat;
(function (IOFormat) {
    IOFormat["YAML"] = "yaml";
    IOFormat["JSON"] = "json";
    // for input, this is Q & A or command line, for output, it's a human-readable table format
    IOFormat["COMMON"] = "common";
})(IOFormat = exports.IOFormat || (exports.IOFormat = {}));
function formatFromFilename(filename) {
    const ext = path_1.default.extname(filename).toLowerCase();
    if (ext === '.yaml' || ext === '.yml') {
        return IOFormat.YAML;
    }
    if (ext === '.json') {
        return IOFormat.JSON;
    }
    logger_1.logManager.getLogger('cli').warn(`could not determine file type from filename "${filename}, assuming YAML`);
    return IOFormat.YAML;
}
exports.formatFromFilename = formatFromFilename;
function parseJSONOrYAML(rawInputData, source) {
    const data = js_yaml_1.default.safeLoad(rawInputData);
    if (!data) {
        throw Error(`did not get any data from ${source}`);
    }
    if (typeof data === 'string') {
        throw Error(`got simple string from ${source}`);
    }
    return data;
}
exports.parseJSONOrYAML = parseJSONOrYAML;
function readDataFromStdin() {
    return new Promise((resolve, reject) => {
        try {
            const stdin = process.stdin;
            const inputChunks = [];
            stdin.resume();
            stdin.on('data', chunk => {
                inputChunks.push(chunk.toString());
            });
            stdin.on('end', () => {
                resolve(inputChunks.join(''));
            });
        }
        catch (error) {
            reject(error);
        }
    });
}
exports.readDataFromStdin = readDataFromStdin;
/**
 * Simple function to test for TTY input. Use this instead of directly calling `process` if you want
 * to mock in unit tests.
 */
function stdinIsTTY() {
    return process.stdin.isTTY;
}
exports.stdinIsTTY = stdinIsTTY;
/**
 * Simple function to test for TTY output. Use this instead of directly calling `process` if you want
 * to mock in unit tests.
 */
function stdoutIsTTY() {
    return process.stdout.isTTY;
}
exports.stdoutIsTTY = stdoutIsTTY;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChannelsEndpoint = void 0;
const core_sdk_1 = require("@smartthings/core-sdk");
class ChannelsEndpoint extends core_sdk_1.Endpoint {
    constructor(config) {
        super(new core_sdk_1.EndpointClient('distchannels', {
            ...config,
            headers: { ...config.headers, Accept: 'application/vnd.smartthings+json;v=20200810' },
        }));
    }
    async create(data) {
        return this.client.post('', data);
    }
    async delete(id) {
        return this.client.delete(id);
    }
    async update(id, data) {
        return this.client.put(id, data);
    }
    async get(id) {
        return this.client.get(id, undefined);
    }
    async getDriverChannelMetaInfo(channelId, driverId) {
        return this.client.get(`${channelId}/drivers/${driverId}/meta`);
    }
    async list(options = {}) {
        const params = {};
        if (typeof (options.includeReadOnly) === 'boolean') {
            params.includeReadOnly = options.includeReadOnly.toString();
        }
        return this.client.getPagedItems('', params);
    }
    async listAssignedDrivers(channelId) {
        return this.client.getPagedItems(`${channelId}/drivers`);
    }
    /**
     * Assign or publish a driver to a channel.
     *
     * NOTE: This method works as an update as well.
     */
    async assignDriver(channelId, driverId, version) {
        return this.client.post(`${channelId}/drivers`, { driverId, version });
    }
    async unassignDriver(channelId, driverId) {
        await this.client.delete(`${channelId}/drivers/${driverId}`);
    }
    async enrollHub(channelId, hubId) {
        await this.client.post(`${channelId}/hubs/${hubId}`);
    }
    async unenrollHub(channelId, hubId) {
        await this.client.delete(`${channelId}/hubs/${hubId}`);
    }
}
exports.ChannelsEndpoint = ChannelsEndpoint;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.chooseCapabilityFiltered = exports.chooseCapability = exports.translateToId = exports.getIdFromUser = exports.getAllFiltered = exports.getStandard = exports.getCustomByNamespace = exports.buildListTableOutput = exports.buildTableOutput = exports.attributeType = exports.capabilityIdOrIndexInputArgs = exports.capabilityIdInputArgs = void 0;
const tslib_1 = require("tslib");
const inquirer_1 = tslib_1.__importDefault(require("inquirer"));
const command_1 = require("@oclif/command");
const cli_lib_1 = require("@smartthings/cli-lib");
exports.capabilityIdInputArgs = [
    {
        name: 'id',
        description: 'the capability id',
    },
    {
        name: 'version',
        description: 'the capability version',
    },
];
exports.capabilityIdOrIndexInputArgs = [
    {
        name: 'id',
        description: 'the capability id or number in list',
    },
    {
        name: 'version',
        description: 'the capability version',
    },
];
function joinEnums(enums, width) {
    let result = '';
    let lineWidth = 0;
    for (const item of enums) {
        if (result) {
            if (lineWidth + item.length + 2 <= width) {
                result += ', ';
                lineWidth += item.length + 2;
            }
            else {
                result += '\n';
                lineWidth = 0;
            }
        }
        else {
            lineWidth += item.length + 2;
        }
        result += item;
    }
    return result;
}
function attributeType(attr, multilineObjects = true) {
    if (attr.type === 'array') {
        if (Array.isArray(attr.items)) {
            return 'array[' + attr.items.map(it => it.type).join(', ') + ']';
        }
        else if (attr.items) {
            return `array<${attr.items.type}>`;
        }
    }
    else if (attr.type === 'object') {
        if (attr.properties) {
            const props = attr.properties;
            if (multilineObjects) {
                return '{\n' + Object.keys(props).map(it => {
                    const item = props[it];
                    return `  ${it}: ${item ? item.type : 'undefined'}`;
                }).join('\n') + '\n}';
            }
            else {
                return '{' + Object.keys(props).map(it => {
                    const item = props[it];
                    return `${it}: ${item ? item.type : 'undefined'}`;
                }).join(', ') + '}';
            }
        }
        else {
            return attr.title || 'object';
        }
    }
    if (attr.enum) {
        return `enum {${joinEnums(attr.enum, 50)}}`;
    }
    return attr.type || 'undefined';
}
exports.attributeType = attributeType;
function buildTableOutput(tableGenerator, capability) {
    let SubItemTypes;
    (function (SubItemTypes) {
        SubItemTypes["COMMANDS"] = "commands";
        SubItemTypes["ATTRIBUTES"] = "attributes";
    })(SubItemTypes || (SubItemTypes = {}));
    const makeTable = (capability, type) => {
        const headers = type === SubItemTypes.ATTRIBUTES
            ? ['Name', 'Type', 'Setter']
            : ['Name', 'Arguments'];
        const table = tableGenerator.newOutputTable({ head: headers });
        for (const name in capability[type]) {
            if (type === SubItemTypes.ATTRIBUTES) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const subItem = capability[SubItemTypes.ATTRIBUTES][name];
                //table.push([name, subItem.schema.properties.value.type, subItem.setter || ''])
                table.push([name, attributeType(subItem.schema.properties.value), subItem.setter || '']);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const subItem = capability[SubItemTypes.COMMANDS][name];
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                table.push([name, subItem.arguments.map((it) => {
                        var _a;
                        return it.optional ?
                            `${it.name}: ${(_a = it.schema) === null || _a === void 0 ? void 0 : _a.type} (optional)` :
                            `${it.name}: ${attributeType(it.schema)}`;
                    })
                        .join('\n')]);
            }
        }
        return table.toString();
    };
    let output = `\n\nCapability: ${capability.id}\n`;
    if (capability.attributes && Object.keys(capability.attributes).length > 0) {
        output += '\n\nAttributes: \n';
        output += makeTable(capability, SubItemTypes.ATTRIBUTES);
    }
    if (capability.commands && Object.keys(capability.commands).length > 0) {
        output += '\n\nCommands: \n';
        output += makeTable(capability, SubItemTypes.COMMANDS);
    }
    return output;
}
exports.buildTableOutput = buildTableOutput;
function buildListTableOutput(capabilities) {
    return this.tableGenerator.buildTableFromList(capabilities, ['id', 'version', 'status']);
}
exports.buildListTableOutput = buildListTableOutput;
/**
 * Get all custom capabilities for all namespaces and include `namespace` as a
 * property in the results. If no namespace is specified, this will make an API
 * call to get all namespaces and list capabilities for all of them.
 */
async function getCustomByNamespace(client, namespace) {
    let namespaces = [];
    if (namespace) {
        namespaces = [namespace];
    }
    else {
        namespaces = (await client.capabilities.listNamespaces()).map((ns) => ns.name);
    }
    if (!namespaces || namespaces.length == 0) {
        throw Error('could not find any namespaces for your account. Perhaps ' +
            "you haven't created any capabilities yet.");
    }
    let capabilities = [];
    for (const namespace of namespaces) {
        const caps = await client.capabilities.list(namespace);
        capabilities = capabilities.concat(caps.map((capability) => { return { ...capability, namespace }; }));
    }
    return capabilities;
}
exports.getCustomByNamespace = getCustomByNamespace;
async function getStandard(client) {
    const caps = await client.capabilities.listStandard();
    return caps.map((capability) => { return { ...capability, namespace: 'st' }; });
}
exports.getStandard = getStandard;
async function getAllFiltered(client, filter) {
    const list = (await Promise.all([getStandard(client), getCustomByNamespace(client)])).flat();
    if (filter) {
        filter = filter.toLowerCase();
        return list.filter(capability => capability.id.toLowerCase().includes(filter) && capability.status !== 'deprecated');
    }
    return list;
}
exports.getAllFiltered = getAllFiltered;
// eslint-disable-next-line @typescript-eslint/no-unused-vars
async function getIdFromUser(fieldInfo, list, promptMessage) {
    const convertToId = (itemIdOrIndex) => {
        if (itemIdOrIndex.length === 0) {
            return false;
        }
        const matchingItem = list.find(item => itemIdOrIndex === item.id);
        if (matchingItem) {
            return itemIdOrIndex;
        }
        const index = Number.parseInt(itemIdOrIndex);
        if (!Number.isNaN(index) && index > 0 && index <= list.length) {
            const id = list[index - 1].id;
            if (typeof id === 'string') {
                return id;
            }
            else {
                throw Error(`invalid type ${typeof id} for primary key` +
                    ` id in ${JSON.stringify(list[index - 1])}`);
            }
        }
        else {
            return false;
        }
    };
    const idOrIndex = (await inquirer_1.default.prompt({
        type: 'input',
        name: 'idOrIndex',
        message: promptMessage !== null && promptMessage !== void 0 ? promptMessage : 'Enter id or index',
        validate: input => {
            return convertToId(input)
                ? true
                : `Invalid id or index ${input}. Please enter an index or valid id.`;
        },
    })).idOrIndex;
    const inputId = convertToId(idOrIndex);
    if (inputId === false) {
        throw Error(`unable to convert ${idOrIndex} to id`);
    }
    // TODO: check for version
    // currently the version is always 1. Once it's possible to have
    // other values we should:
    // - check here if there are more than one
    //    - if not, use the one there is
    //    - if so, ask the user which one
    return { 'id': inputId, 'version': 1 };
}
exports.getIdFromUser = getIdFromUser;
async function translateToId(sortKeyName, idOrIndex, listFunction) {
    if (typeof idOrIndex !== 'string') {
        return idOrIndex;
    }
    const index = Number.parseInt(idOrIndex);
    if (isNaN(index)) {
        // TODO: when versions are supported, look up and use the most recent
        // version here instead of 1
        return { id: idOrIndex, version: 1 };
    }
    const items = cli_lib_1.sort(await listFunction(), sortKeyName);
    if (index < 1 || index > items.length) {
        throw Error(`invalid index ${index} (enter an id or index between 1 and ${items.length} inclusive)`);
    }
    const matchingItem = items[index - 1];
    return { id: matchingItem.id, version: matchingItem.version };
}
exports.translateToId = translateToId;
async function chooseCapability(command, idFromArgs, versionFromArgs, prompt) {
    const preselectedId = idFromArgs ? { id: idFromArgs, version: versionFromArgs !== null && versionFromArgs !== void 0 ? versionFromArgs : 1 } : undefined;
    const config = {
        itemName: 'capability',
        primaryKeyName: 'id',
        sortKeyName: 'id',
        listTableFieldDefinitions: ['id', 'version', 'status'],
    };
    return cli_lib_1.selectGeneric(command, config, preselectedId, () => getCustomByNamespace(command.client), getIdFromUser, prompt);
}
exports.chooseCapability = chooseCapability;
async function chooseCapabilityFiltered(command, prompt, filter) {
    const config = {
        itemName: 'capability',
        primaryKeyName: 'id',
        sortKeyName: 'id',
        listTableFieldDefinitions: ['id', 'version', 'status'],
    };
    return cli_lib_1.selectGeneric(command, config, undefined, () => getAllFiltered(command.client, filter), getIdFromUser, prompt, false);
}
exports.chooseCapabilityFiltered = chooseCapabilityFiltered;
class CapabilitiesCommand extends cli_lib_1.APICommand {
    async run() {
        const { args, argv, flags } = this.parse(CapabilitiesCommand);
        await super.setup(args, argv, flags);
        const idOrIndex = args.version ? { id: args.id, version: args.version } : args.id;
        const config = {
            primaryKeyName: 'id',
            sortKeyName: 'id',
            listTableFieldDefinitions: ['id', 'version', 'status'],
            buildTableOutput: (data) => buildTableOutput(this.tableGenerator, data),
        };
        await cli_lib_1.outputGenericListing(this, config, idOrIndex, () => flags.standard ? getStandard(this.client) : getCustomByNamespace(this.client, flags.namespace), (id) => this.client.capabilities.get(id.id, id.version), (idOrIndex, listFunction) => translateToId(config.sortKeyName, idOrIndex, listFunction));
    }
}
exports.default = CapabilitiesCommand;
CapabilitiesCommand.description = 'get a specific capability';
CapabilitiesCommand.flags = {
    ...cli_lib_1.APICommand.flags,
    ...cli_lib_1.outputGenericListing.flags,
    namespace: command_1.flags.string({
        char: 'n',
        description: 'a specific namespace to query; will use all by default',
    }),
    standard: command_1.flags.boolean({
        char: 's',
        description: 'show standard SmartThings capabilities',
    }),
};
CapabilitiesCommand.args = exports.capabilityIdOrIndexInputArgs;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseDeviceCommand = exports.parseArguments = void 0;
const tslib_1 = require("tslib");
const inquirer_1 = tslib_1.__importDefault(require("inquirer"));
const cli_lib_1 = require("@smartthings/cli-lib");
const capabilities_1 = require("../capabilities");
const inputRegex = new RegExp(/^([a-zA-Z0-9]+:)?([a-zA-Z0-9]+:)?([a-zA-Z0-9]+(\(.*\))?)?$/);
function parseArguments(str) {
    return JSON.parse(`[${str}]`);
}
exports.parseArguments = parseArguments;
function parseDeviceCommand(str, componentId, capabilityId) {
    let cmdStr = str;
    let args = [];
    const pos = str.indexOf('(');
    if (pos > 0) {
        cmdStr = str.slice(0, pos);
        const argStr = str.slice(pos + 1, -1);
        args = JSON.parse(`[${argStr}]`);
    }
    const segs = cmdStr.split(':');
    const component = componentId ?
        componentId :
        (segs.length === 2 ? 'main' : segs[0]);
    const capability = capabilityId ?
        capabilityId :
        (componentId ?
            segs[0] :
            (segs.length > 1 ?
                (segs.length === 2 ? segs[0] : segs[1]) :
                ''));
    let command = '';
    if (componentId) {
        if (capabilityId) {
            command = segs[0];
        }
        else {
            if (segs.length === 2) {
                command = segs[1];
            }
        }
    }
    else {
        if (segs.length === 3) {
            command = segs[2];
        }
        if (segs.length === 2) {
            command = segs[1];
        }
    }
    return {
        component: component,
        capability: capability,
        command: command,
        arguments: args,
    };
}
exports.parseDeviceCommand = parseDeviceCommand;
class DeviceCommandsCommand extends cli_lib_1.APICommand {
    hasCommandLineInput() {
        return !!this.args.command;
    }
    async getInputFromCommandLine() {
        return [parseDeviceCommand(this.args.command)];
    }
    async getComponentFromUser(device, cmd) {
        if (device.components && device.components.length > 1) {
            this.log('\nComponents:');
            let index = 1;
            const table = this.tableGenerator.newOutputTable();
            for (const comp of device.components) {
                table.push([index, comp.id]);
                index++;
            }
            this.log(table.toString());
            const input = (await inquirer_1.default.prompt({
                type: 'input',
                name: 'component',
                message: 'Enter component index or id',
                validate: (input) => {
                    return inputRegex.test(input) || 'Invalid command syntax';
                },
            })).component;
            if (cli_lib_1.isIndexArgument(input)) {
                cmd.component = device.components[Number.parseInt(input) - 1].id || '';
            }
            else {
                cmd = parseDeviceCommand(input);
            }
            if (cmd.component === '') {
                this.abort('Command aborted');
            }
        }
        return cmd;
    }
    async getCapabilityFromUser(component, cmd) {
        if (component.capabilities.length > 1) {
            this.log('\nCapabilities:');
            let index = 1;
            const table = this.tableGenerator.newOutputTable();
            for (const cap of component.capabilities) {
                table.push([index, cap.id]);
                index++;
            }
            this.log(table.toString());
            const input = (await inquirer_1.default.prompt({
                type: 'input',
                name: 'capability',
                message: 'Enter capability index or id',
                validate: (input) => {
                    return inputRegex.test(input) || 'Invalid command syntax';
                },
            })).capability;
            if (cli_lib_1.isIndexArgument(input)) {
                cmd.capability = component.capabilities[Number.parseInt(input) - 1].id || '';
            }
            else {
                cmd = parseDeviceCommand(input, cmd.component);
            }
            if (cmd.capability === '') {
                this.abort('Command aborted');
            }
        }
        else {
            cmd.capability = component.capabilities[0].id;
        }
        return cmd;
    }
    async getCommandFromUser(cap, cmd) {
        var _a, _b, _c;
        const capability = await this.client.capabilities.get(cap.id, cap.version || 1);
        if (capability.commands && Object.keys(capability.commands).length > 0) {
            this.log('\nCommands:');
            let index = 1;
            const commandNames = Object.keys(capability.commands);
            const table = this.tableGenerator.newOutputTable();
            for (const commandName of commandNames) {
                const command = capability.commands[commandName];
                const args = ((_a = command === null || command === void 0 ? void 0 : command.arguments) === null || _a === void 0 ? void 0 : _a.map(it => it.optional ? `[${it.name}<${capabilities_1.attributeType(it.schema)}>]` : `${it.name}<${capabilities_1.attributeType(it.schema)}>`).join(', ')) || '';
                table.push([index, `${commandName}(${args})`]);
                index++;
            }
            this.log(table.toString());
            const input = (await inquirer_1.default.prompt({
                type: 'input',
                name: 'command',
                message: 'Enter command',
                validate: (input) => {
                    return inputRegex.test(input) || 'Invalid command syntax';
                },
            })).command;
            if (cli_lib_1.isIndexArgument(input)) {
                cmd.command = commandNames[Number.parseInt(input) - 1];
            }
            else {
                cmd = parseDeviceCommand(input, cmd.component, cmd.capability);
            }
            if (cmd.command === '') {
                this.abort('Command aborted');
            }
            const command = capability.commands[cmd.command];
            if (command.arguments && ((_b = command.arguments) === null || _b === void 0 ? void 0 : _b.length) > 0 && (!cmd.arguments || cmd.arguments.length === 0)) {
                const args = ((_c = command === null || command === void 0 ? void 0 : command.arguments) === null || _c === void 0 ? void 0 : _c.map(it => it.optional ? `[${it.name}]` : it.name).join(', ')) || '';
                const input = (await inquirer_1.default.prompt({
                    type: 'input',
                    name: 'arguments',
                    message: `Enter command arguments (${args})`,
                })).arguments;
                if (input === '') {
                    this.abort('Command aborted');
                }
                cmd.arguments = parseArguments(input);
            }
        }
        else {
            this.abort('Capability has no commands');
        }
        return cmd;
    }
    async getInputFromUser(deviceId) {
        var _a;
        const device = await this.client.devices.get(deviceId);
        this.log('\n' + device.label);
        let cmd = {
            component: 'main',
            capability: '',
            command: '',
        };
        cmd = await this.getComponentFromUser(device, cmd);
        if (!cmd.capability) {
            const component = (_a = device.components) === null || _a === void 0 ? void 0 : _a.find(it => it.id === cmd.component);
            if (component) {
                cmd = await this.getCapabilityFromUser(component, cmd);
            }
            else {
                throw new Error(`Component '${cmd.component}' not found`);
            }
            if (!cmd.command) {
                const cap = component.capabilities.find(it => it.id === cmd.capability);
                if (cap) {
                    cmd = await this.getCommandFromUser(cap, cmd);
                }
                else {
                    throw new Error(`Capability '${cmd.capability}' of component '${cmd.component}' not found`);
                }
            }
        }
        return [cmd];
    }
    async run() {
        const { args, argv, flags } = this.parse(DeviceCommandsCommand);
        await super.setup(args, argv, flags);
        const config = {
            primaryKeyName: 'deviceId',
            sortKeyName: 'label',
            listTableFieldDefinitions: ['label', 'name', 'type', 'deviceId'],
        };
        const deviceId = await cli_lib_1.selectFromList(this, config, args.id, () => this.client.devices.list());
        const [commands] = await cli_lib_1.inputItem(this, cli_lib_1.commandLineInputProcessor(this), cli_lib_1.inputProcessor(() => true, () => this.getInputFromUser(deviceId)));
        await this.client.devices.executeCommands(deviceId, commands);
        this.log('Command executed successfully');
    }
}
exports.default = DeviceCommandsCommand;
DeviceCommandsCommand.description = 'execute a device command';
DeviceCommandsCommand.flags = {
    ...cli_lib_1.APICommand.flags,
    ...cli_lib_1.inputItem.flags,
};
DeviceCommandsCommand.args = [
    {
        name: 'id',
        description: 'the device id',
    },
    {
        name: 'command',
        description: 'the command [<component>]:<capability>:<command>([<arguments>])',
    },
];

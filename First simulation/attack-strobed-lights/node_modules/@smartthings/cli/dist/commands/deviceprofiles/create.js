"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cleanupRequest = exports.createWithDefaultConfig = exports.generateDefaultConfig = void 0;
const tslib_1 = require("tslib");
const errors_1 = require("@oclif/errors");
const inquirer_1 = tslib_1.__importDefault(require("inquirer"));
const cli_lib_1 = require("@smartthings/cli-lib");
const deviceprofiles_1 = require("../deviceprofiles");
const capabilities_1 = require("../capabilities");
const capabilitiesWithoutPresentations = ['healthCheck', 'execute'];
async function generateDefaultConfig(client, deviceProfileId, deviceProfile) {
    // Generate the default config
    const deviceConfig = await client.presentation.generate(deviceProfileId);
    // Edit the dashboard entries to include only the first capability in the profile
    if (deviceProfile.components && deviceConfig.dashboard) {
        const firstComponent = deviceProfile.components[0];
        if (firstComponent.capabilities && firstComponent.capabilities.length > 0) {
            const firstCapability = firstComponent.capabilities[0];
            const capability = await client.capabilities.get(firstCapability.id, firstCapability.version || 1);
            if (capability.attributes && Object.keys(capability.attributes).length > 0) {
                deviceConfig.dashboard.states = deviceConfig.dashboard.states.filter(it => it.component === firstComponent.id && it.capability === firstCapability.id);
            }
            else {
                deviceConfig.dashboard.states = [];
            }
            if (capability.commands && Object.keys(capability.commands).length > 0) {
                deviceConfig.dashboard.actions = deviceConfig.dashboard.actions.filter(it => it.component === firstComponent.id && it.capability === firstCapability.id);
            }
            else {
                deviceConfig.dashboard.actions = [];
            }
        }
    }
    // Filter capabilities with no UI
    if (deviceConfig.detailView) {
        deviceConfig.detailView = deviceConfig.detailView.filter(it => !(capabilitiesWithoutPresentations.includes(it.capability)));
    }
    // Filter automation entries
    if (deviceConfig.automation) {
        // Filter out conditions for capabilities that don't have attributes
        if (deviceConfig.automation.conditions) {
            const capabilities = await Promise.all(deviceConfig.automation.conditions.map(it => {
                return client.capabilities.get(it.capability, it.version || 1);
            }));
            deviceConfig.automation.conditions = deviceConfig.automation.conditions.filter((_v, index) => {
                const capability = capabilities[index];
                return capability.attributes && Object.keys(capability.attributes).length > 0 && !(capabilitiesWithoutPresentations.includes(capability.id || ''));
            });
        }
        // Filter out automation actions for capabilities that don't have commands
        if (deviceConfig.automation.actions) {
            const capabilities = await Promise.all(deviceConfig.automation.actions.map(it => {
                return client.capabilities.get(it.capability, it.version || 1);
            }));
            deviceConfig.automation.actions = deviceConfig.automation.actions.filter((_v, index) => {
                const capability = capabilities[index];
                return capability.commands && Object.keys(capability.commands).length > 0 && !(capabilitiesWithoutPresentations.includes(capability.id || ''));
            });
        }
    }
    return deviceConfig;
}
exports.generateDefaultConfig = generateDefaultConfig;
async function createWithDefaultConfig(client, data) {
    // Create the profile
    let deviceProfile = await client.deviceProfiles.create(cleanupRequest(data));
    // Generate the default config
    const deviceConfigData = await generateDefaultConfig(client, deviceProfile.id, deviceProfile);
    // Create the config using the default
    const deviceConfig = await client.presentation.create(deviceConfigData);
    // Update the profile to use the vid from the config
    const profileId = deviceProfile.id;
    cleanupRequest(deviceProfile);
    // TODO: I'm guessing name should be optional in PresentationDeviceConfigEntry
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    delete deviceProfile.name;
    if (!deviceProfile.metadata) {
        deviceProfile.metadata = {};
    }
    deviceProfile.metadata.vid = deviceConfig.presentationId;
    deviceProfile.metadata.mnmn = deviceConfig.manufacturerName;
    // Update the profile with the vid and mnmn
    deviceProfile = await client.deviceProfiles.update(profileId, deviceProfile);
    // Return the composite object
    return { deviceProfile, deviceConfig };
}
exports.createWithDefaultConfig = createWithDefaultConfig;
// Cleanup is done so that the result of a device profile get can be modified and
// used in an update operation without having to delete the status, owner, and
// component name fields, which aren't accepted in the update API call.
function cleanupRequest(deviceProfileRequest) {
    delete deviceProfileRequest.id;
    delete deviceProfileRequest.status;
    delete deviceProfileRequest.restrictions;
    if (deviceProfileRequest.components) {
        for (const component of deviceProfileRequest.components) {
            delete component.label;
        }
    }
    return deviceProfileRequest;
}
exports.cleanupRequest = cleanupRequest;
class DeviceProfileCreateCommand extends cli_lib_1.APICommand {
    async run() {
        const { args, argv, flags } = this.parse(DeviceProfileCreateCommand);
        await super.setup(args, argv, flags);
        const createDeviceProfile = async (_, data) => {
            var _a;
            if (data.view) {
                throw new Error('Input contains "view" property. Use deviceprofiles:view:create instead.');
            }
            if (!((_a = data.metadata) === null || _a === void 0 ? void 0 : _a.vid)) {
                const profileAndConfig = await createWithDefaultConfig(this.client, data);
                return profileAndConfig.deviceProfile;
            }
            return await this.client.deviceProfiles.create(cleanupRequest(data));
        };
        await cli_lib_1.inputAndOutputItem(this, { buildTableOutput: data => deviceprofiles_1.buildTableOutput(this.tableGenerator, data) }, createDeviceProfile, cli_lib_1.userInputProcessor(this));
    }
    // TODO - update once capability versions are supported
    async capabilityDefined(idStr) {
        try {
            const capability = await this.client.capabilities.get(idStr, 1);
            return !!capability;
        }
        catch (e) {
            return false;
        }
    }
    async promptAndAddCapability(deviceProfile, componentId, prompt = 'Capability ID') {
        var _a, _b;
        let capabilityId = { id: '', version: 0 };
        const idStr = (await inquirer_1.default.prompt({
            type: 'input',
            name: 'id',
            message: `${prompt} (type ? for a list):`,
            validate: async (input) => {
                return (input.endsWith('?') || input === '' || await this.capabilityDefined(input))
                    ? true
                    : `Invalid ID "${input}". Please enter a valid capability ID or ? for a list of available capabilities.`;
            },
        })).id;
        if (idStr) {
            if (idStr.endsWith('?')) {
                capabilityId = await capabilities_1.chooseCapabilityFiltered(this, `${prompt}:`, idStr.slice(0, idStr.length - 1));
            }
            else {
                // TODO - update once capability versions are supported
                capabilityId = { id: idStr, version: 1 };
            }
        }
        if (capabilityId && capabilityId.id) {
            const component = (_a = deviceProfile.components) === null || _a === void 0 ? void 0 : _a.find(it => it.id === componentId);
            if (component) {
                (_b = component.capabilities) === null || _b === void 0 ? void 0 : _b.push(capabilityId);
            }
            else {
                throw new errors_1.CLIError(`Component ${componentId} not defined in profile`);
            }
        }
        return capabilityId;
    }
    async promptAndAddComponent(deviceProfile, previousComponentId) {
        const components = deviceProfile.components || [];
        let componentId = (await inquirer_1.default.prompt({
            type: 'input',
            name: 'componentId',
            message: 'ComponentId ID: ',
            validate: (input) => {
                return (new RegExp(/^[0-9a-zA-Z]{1,100}$/).test(input) && !components.find(it => it.id === input)) || 'Invalid component name';
            },
        })).componentId;
        if (componentId) {
            components.push({ id: componentId, capabilities: [] });
        }
        else {
            componentId = previousComponentId;
        }
        return componentId;
    }
    async getInputFromUser() {
        const name = (await inquirer_1.default.prompt({
            type: 'input',
            name: 'deviceProfileName',
            message: 'Device Profile Name:',
            validate: (input) => {
                return new RegExp(/^(?!\s)[-_!.~'() *0-9a-zA-Z]{1,100}(?<!\s)$/).test(input) || 'Invalid device profile name';
            },
        })).deviceProfileName;
        const deviceProfile = {
            name,
            components: [
                {
                    id: 'main',
                    capabilities: [],
                },
            ],
        };
        let primaryCapabilityId;
        do {
            primaryCapabilityId = await this.promptAndAddCapability(deviceProfile, 'main', 'Primary capability ID');
        } while (!primaryCapabilityId.id);
        let action;
        let componentId = 'main';
        const choices = ["Add another capability to this component" /* ADD_CAPABILITY */, "Add another component" /* ADD_COMPONENT */, "Finish & Create" /* FINISH */];
        do {
            action = (await inquirer_1.default.prompt({
                type: 'list',
                name: 'action',
                message: 'Select an action...',
                choices,
            })).action;
            if (action === "Add another capability to this component" /* ADD_CAPABILITY */) {
                await this.promptAndAddCapability(deviceProfile, componentId);
            }
            else if (action === "Add another component" /* ADD_COMPONENT */) {
                componentId = await this.promptAndAddComponent(deviceProfile, componentId);
                await this.promptAndAddCapability(deviceProfile, componentId);
            }
        } while (action !== "Finish & Create" /* FINISH */);
        return deviceProfile;
    }
}
exports.default = DeviceProfileCreateCommand;
DeviceProfileCreateCommand.description = 'Create a new device profile\n' +
    'Creates a new device profile. If a vid field is not present in the meta\n' +
    'then a default device presentation will be created for this profile and the\n' +
    'vid set to reference it.';
DeviceProfileCreateCommand.flags = {
    ...cli_lib_1.APICommand.flags,
    ...cli_lib_1.inputAndOutputItem.flags,
};
DeviceProfileCreateCommand.examples = [
    '$ smartthings deviceprofiles:create -i myprofile.json    # create a device profile from the JSON file definition',
    '$ smartthings deviceprofiles:create -i myprofile.yaml    # create a device profile from the YAML file definition',
    '$ smartthings deviceprofiles:create                      # create a device profile with interactive dialog',
];
DeviceProfileCreateCommand.aliases = ['device-profiles:create'];

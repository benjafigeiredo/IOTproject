import Table from 'cli-table';
import { Logger } from '@smartthings/core-sdk';
/**
 * This code is copied from the DefinitelyTyped source code because it is not
 * exported there.
 *
 * https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/cli-table/index.d.ts
 *
 * TODO: open a pull request to export this in DefinitelyTyped
 */
export interface TableOptions {
    chars: Partial<Record<('top' | 'top-mid' | 'top-left' | 'top-right' | 'bottom' | 'bottom-mid' | 'bottom-left' | 'bottom-right' | 'left' | 'left-mid' | 'mid' | 'mid-mid' | 'right' | 'right-mid' | 'middle'), string>>;
    truncate: string;
    colors: boolean;
    colWidths: number[];
    colAligns: Array<'left' | 'middle' | 'right'>;
    style: Partial<{
        'padding-left': number;
        'padding-right': number;
        head: string[];
        border: string[];
        compact: boolean;
    }>;
    head: string[];
}
/**
 * Used to define a field in an output table.
 *
 * If the name of the property can programmatically be converted to the name
 * of the header, a simple string can be used. For example, if the name of
 * the field is "maxValue", using the string "maxValue" here will result
 * in a heading name of "Max Value" and data is retrieved simply from the
 * "maxValue" property.
 *
 * If more control is needed, a more complex definition can be included.
 *
 * Leaving out both label and value is the equivalent of using a simple string
 * for the definition.
 */
export declare type TableFieldDefinition<T> = string | {
    /**
     * The name of the property from which to get data. This reference a nested
     * property if desired.
     *
     * The Lodash _.at function is used to access the property but any path
     * used should return a single value.
     *
     * https://lodash.com/docs/4.17.15#at
     *
     * The default label is also derived from this field when the `label`
     * property is not included. Only the final property in the path is used.
     */
    prop?: string;
    /**
     * If included, the header (column or row depending on the type of table),
     * will come from label. If not included, it will be the property
     * name with the first letter made uppercase and spaces added before other
     * uppercase letters.
     */
    label?: string;
    /**
     * If included, the displayValue function will be called to get the value
     * to be displayed. If not, the property of the given name, simply coerced
     * to a string, will be used.
     */
    value?: (i: T) => string | undefined;
    /**
     * Use this function if you want to optionally include this field.
     *
     * If this function is defined and it returns `false`, the field will
     * be skipped. This really only makes sense in tables that are
     * "single item" tables where the first column is the label
     * and the second is the display value (i.e. tables built with
     * `TableGenerator.buildTableFromItem`.)
     */
    include?: (i: T) => boolean;
    /**
     * If included and set to true, skip the row if it the value is empty.
     * This is a shortcut for an `include` method that would just do that
     * check.
     */
    skipEmpty?: boolean;
};
export interface TableGenerator {
    newOutputTable(options?: Partial<TableOptions>): Table;
    /**
     * Build a table for a specific item. There will be no header and the table
     * will have two columns. The first displays the label for each property
     * and the second the associated value.
     */
    buildTableFromItem<T>(item: T, tableFieldDefinitions: TableFieldDefinition<T>[]): string;
    /**
     * Build a table for a list of items. The first row will be the header row,
     * displaying labels for all the tableFieldDefinitions and there will be
     * one row for each item in the items list displaying the associated values.
     */
    buildTableFromList<T>(items: T[], tableFieldDefinitions: TableFieldDefinition<T>[]): string;
}
export declare class DefaultTableGenerator implements TableGenerator {
    private compact;
    constructor(compact: boolean);
    private _logger?;
    protected get logger(): Logger;
    private convertToLabel;
    private getLabelFor;
    private getDisplayValueFor;
    newOutputTable(options?: Partial<TableOptions>): Table;
    buildTableFromItem<T>(item: T, definitions: TableFieldDefinition<T>[]): string;
    buildTableFromList<T>(items: T[], definitions: TableFieldDefinition<T>[]): string;
}

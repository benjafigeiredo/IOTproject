"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveLogClient = exports.handleConnectionErrors = exports.parseIpAndPort = exports.liveLogMessageFormatter = exports.DriverInfoStatus = exports.LogLevel = void 0;
const axios_1 = __importDefault(require("axios"));
const https_1 = __importDefault(require("https"));
const net_1 = __importDefault(require("net"));
const cli_lib_1 = require("@smartthings/cli-lib");
const errors_1 = require("@oclif/errors");
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["TRACE"] = 100] = "TRACE";
    LogLevel[LogLevel["DEBUG"] = 200] = "DEBUG";
    LogLevel[LogLevel["INFO"] = 300] = "INFO";
    LogLevel[LogLevel["WARN"] = 400] = "WARN";
    LogLevel[LogLevel["ERROR"] = 500] = "ERROR";
    LogLevel[LogLevel["FATAL"] = 600] = "FATAL";
    LogLevel[LogLevel["PRINT"] = 1000] = "PRINT";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isLiveLogMessage(event) {
    const liveLogEvent = event;
    return liveLogEvent.timestamp !== undefined &&
        liveLogEvent.driver_id !== undefined &&
        liveLogEvent.driver_name !== undefined &&
        liveLogEvent.log_level !== undefined &&
        liveLogEvent.message !== undefined;
}
var DriverInfoStatus;
(function (DriverInfoStatus) {
    DriverInfoStatus["NoArchive"] = "no archive";
    DriverInfoStatus["Downloading"] = "downloading";
    DriverInfoStatus["Installed"] = "installed";
    DriverInfoStatus["Failure"] = "failure";
    DriverInfoStatus["Unknown"] = "unknown";
})(DriverInfoStatus = exports.DriverInfoStatus || (exports.DriverInfoStatus = {}));
function logLevelColor(level) {
    const bgTrace = cli_lib_1.bgGreen;
    const bgDebug = cli_lib_1.bgCyan;
    const bgInfo = cli_lib_1.bgBlue;
    const bgWarn = cli_lib_1.bgYellow;
    const bgError = cli_lib_1.bgRed;
    const bgFatal = cli_lib_1.bgGray;
    const bgPrint = cli_lib_1.bgGray;
    let colorString;
    switch (level) {
        case LogLevel.TRACE:
            colorString = bgTrace(LogLevel[LogLevel.TRACE]);
            break;
        case LogLevel.DEBUG:
            colorString = bgDebug(LogLevel[LogLevel.DEBUG]);
            break;
        case LogLevel.INFO:
            colorString = bgInfo(LogLevel[LogLevel.INFO]);
            break;
        case LogLevel.WARN:
            colorString = bgWarn(LogLevel[LogLevel.WARN]);
            break;
        case LogLevel.ERROR:
            colorString = bgError(LogLevel[LogLevel.ERROR]);
            break;
        case LogLevel.FATAL:
            colorString = bgFatal(LogLevel[LogLevel.FATAL]);
            break;
        case LogLevel.PRINT:
            colorString = bgPrint(LogLevel[LogLevel.PRINT]);
            break;
        default:
            throw Error('Unknown log level');
    }
    // black text seems to provide better contrast in most terminals
    return cli_lib_1.black(colorString);
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function liveLogMessageFormatter(event) {
    if (isLiveLogMessage(event)) {
        const formatString = `${logLevelColor(event.log_level)} ${event.driver_name}  ${event.message}`;
        const time = event.timestamp;
        return { formatString, time };
    }
    throw Error('Unexpected log message type.');
}
exports.liveLogMessageFormatter = liveLogMessageFormatter;
function parseIpAndPort(address) {
    const items = address.split(':');
    if (items.length > 2) {
        throw new errors_1.CLIError('Invalid IPv4 address and port format.');
    }
    if (!net_1.default.isIPv4(items[0])) {
        throw new errors_1.CLIError('Invalid IPv4 address format.');
    }
    const ipv4 = items[0];
    if (items.length == 1) {
        return [ipv4, undefined];
    }
    const port = Number(items[1]);
    if (Number.isInteger(port) && port >= 0 && port <= 65535) {
        return [ipv4, port.toString()];
    }
    throw new errors_1.CLIError('Invalid port format.');
}
exports.parseIpAndPort = parseIpAndPort;
function handleConnectionErrors(authority, error) {
    const generalMessage = 'Ensure hub address is correct and try again';
    if (error.includes('ECONNREFUSED') || error.includes('EHOSTUNREACH')) {
        throw new errors_1.CLIError(`Unable to connect to ${authority}. ${generalMessage}`);
    }
    else if (error.includes('ETIMEDOUT')) {
        throw new errors_1.CLIError(`Connection to ${authority} timed out. ${generalMessage}`);
    }
    else if (error.includes('EHOSTDOWN')) {
        throw new errors_1.CLIError(`The host at ${authority} is down. ${generalMessage}`);
    }
}
exports.handleConnectionErrors = handleConnectionErrors;
class LiveLogClient {
    constructor(authority, authenticator, verifier) {
        const baseURL = new URL(`https://${authority}`);
        this.authority = authority;
        this.driversURL = new URL('drivers', baseURL);
        this.logsURL = new URL('drivers/logs', baseURL);
        this.authenticator = authenticator;
        this.hostVerified = verifier === undefined;
        this.verifier = verifier;
    }
    async request(url, method = 'GET') {
        const config = await this.authenticator.authenticate({
            url: url,
            method: method,
            httpsAgent: new https_1.default.Agent({ rejectUnauthorized: false }),
            timeout: 5000, // milliseconds
        });
        let response;
        try {
            response = await axios_1.default.request(config);
        }
        catch (error) {
            if (error.isAxiosError) {
                this.handleAxiosConnectionErrors(error);
            }
            throw error;
        }
        if (!this.hostVerified && this.verifier) {
            await this.verifier(this.getCertificate(response));
            this.hostVerified = true;
        }
        return response;
    }
    handleAxiosConnectionErrors(error) {
        if (error.code) {
            // hack to address https://github.com/axios/axios/issues/1543
            if (error.code === 'ECONNABORTED' && error.message.toLowerCase().includes('timeout')) {
                throw new errors_1.CLIError(`Connection to ${this.authority} timed out. ` +
                    'Ensure hub address is correct and try again');
            }
            handleConnectionErrors(this.authority, error.code);
        }
    }
    getCertificate(response) {
        return response.request.connection.getPeerCertificate();
    }
    async getDrivers() {
        return (await this.request(this.driversURL.toString())).data;
    }
    async getLogSource(driverId) {
        const sourceURL = this.logsURL;
        if (driverId) {
            sourceURL.searchParams.set('driver_id', driverId);
        }
        return sourceURL.toString();
    }
}
exports.LiveLogClient = LiveLogClient;

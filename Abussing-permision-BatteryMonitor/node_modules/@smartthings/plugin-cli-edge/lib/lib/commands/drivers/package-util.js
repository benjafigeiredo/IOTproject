"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.processProfiles = exports.processSrcDir = exports.buildTestFileMatchers = exports.processFingerprintsFile = exports.processConfigFile = exports.resolveProjectDirName = void 0;
const fs_1 = __importDefault(require("fs"));
const errors_1 = require("@oclif/errors");
const picomatch_1 = __importDefault(require("picomatch"));
const file_util_1 = require("../../file-util");
const resolveProjectDirName = (projectDirNameFromArgs) => {
    let calculatedProjectDirName = projectDirNameFromArgs;
    if (calculatedProjectDirName.endsWith('/')) {
        calculatedProjectDirName = calculatedProjectDirName.slice(0, -1);
    }
    if (!file_util_1.isDir(calculatedProjectDirName)) {
        throw new errors_1.CLIError(`${calculatedProjectDirName} must exist and be a directory`);
    }
    return calculatedProjectDirName;
};
exports.resolveProjectDirName = resolveProjectDirName;
const processConfigFile = (projectDirectory, zip) => {
    const configFile = file_util_1.findYAMLFilename(`${projectDirectory}/config`);
    if (configFile === false) {
        throw new errors_1.CLIError('missing main config.yaml (or config.yml) file');
    }
    const parsedConfig = file_util_1.readYAMLFile(configFile, 'unable to parse {filename}: {error}');
    if (parsedConfig == null) {
        throw new errors_1.CLIError('empty config file');
    }
    if (typeof parsedConfig === 'string') {
        throw new errors_1.CLIError('invalid config file');
    }
    zip.file('config.yml', fs_1.default.createReadStream(configFile));
    return parsedConfig;
};
exports.processConfigFile = processConfigFile;
const processFingerprintsFile = (projectDirectory, zip) => {
    const fingerprintsFile = file_util_1.findYAMLFilename(`${projectDirectory}/fingerprints`);
    if (fingerprintsFile !== false) {
        // validate file is at least parsable as a YAML file
        file_util_1.readYAMLFile(fingerprintsFile, 'unable to parse {filename}: {error}');
        zip.file('fingerprints.yml', fs_1.default.createReadStream(fingerprintsFile));
    }
};
exports.processFingerprintsFile = processFingerprintsFile;
const buildTestFileMatchers = (matchersFromConfig) => {
    const retVal = [];
    const config = matchersFromConfig;
    if (typeof config === 'string') {
        retVal.push(picomatch_1.default(config));
    }
    else if (Array.isArray(config)) {
        for (const glob of config) {
            retVal.push(picomatch_1.default(glob));
        }
    }
    else {
        retVal.push(picomatch_1.default('test/**'));
        retVal.push(picomatch_1.default('tests/**'));
    }
    return retVal;
};
exports.buildTestFileMatchers = buildTestFileMatchers;
const processSrcDir = (projectDirectory, zip, testFileMatchers) => {
    const srcDir = file_util_1.requireDir(`${projectDirectory}/src`);
    if (!file_util_1.isFile(`${srcDir}/init.lua`)) {
        throw new errors_1.CLIError(`missing required ${srcDir}/init.lua file`);
    }
    // The max depth is 10 but the main project directory and the src directory itself count,
    // so we start at 2.
    const walkDir = (fromDir, nested = 2) => {
        for (const filename of fs_1.default.readdirSync(fromDir)) {
            const fullFilename = `${fromDir}/${filename}`;
            if (file_util_1.isDir(fullFilename)) {
                // maximum depth is defined by server
                if (nested < 10) {
                    walkDir(fullFilename, nested + 1);
                }
                else {
                    throw new errors_1.CLIError(`drivers directory nested too deeply (at ${fullFilename}); max depth is 10`);
                }
            }
            else {
                const filenameForTestMatch = fullFilename.substr(srcDir.length + 1);
                if (!testFileMatchers.some(matcher => matcher(filenameForTestMatch))) {
                    const archiveName = `src${fullFilename.substring(srcDir.length)}`;
                    zip.file(archiveName, fs_1.default.createReadStream(fullFilename));
                }
            }
        }
    };
    walkDir(srcDir);
};
exports.processSrcDir = processSrcDir;
const processProfiles = (projectDirectory, zip) => {
    const profilesDir = file_util_1.requireDir(`${projectDirectory}/profiles`);
    for (const filename of fs_1.default.readdirSync(profilesDir)) {
        const fullFilename = `${profilesDir}/${filename}`;
        if (filename.endsWith('.yaml') || filename.endsWith('.yml')) {
            // read and parse to make sure profiles are at least valid yaml
            file_util_1.readYAMLFile(fullFilename);
            let archiveName = `profiles${fullFilename.substring(profilesDir.length)}`;
            if (archiveName.endsWith('.yaml')) {
                archiveName = `${archiveName.slice(0, -4)}yml`;
            }
            zip.file(archiveName, fs_1.default.createReadStream(fullFilename));
        }
        else {
            throw new errors_1.CLIError(`invalid profile file "${fullFilename}" (must have .yaml or .yml extension)`);
        }
    }
};
exports.processProfiles = processProfiles;

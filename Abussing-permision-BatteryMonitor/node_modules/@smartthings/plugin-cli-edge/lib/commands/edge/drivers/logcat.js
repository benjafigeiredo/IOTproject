"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const errors_1 = require("@oclif/errors");
const cli_ux_1 = __importDefault(require("cli-ux"));
const inquirer_1 = __importDefault(require("inquirer"));
const fs_1 = require("fs");
const live_logging_1 = require("../../../lib/live-logging");
const cli_lib_1 = require("@smartthings/cli-lib");
const DEFAULT_ALL_TEXT = 'all';
const DEFAULT_LIVE_LOG_PORT = 9495;
/**
 * Define labels to stay consistent with other driver commands
 */
const driverFieldDefinitions = [
    {
        prop: 'driver_id',
        label: 'Driver Id',
    },
    {
        prop: 'driver_name',
        label: 'Name',
    },
];
async function promptForDrivers(fieldInfo, list, prompt) {
    const primaryKeyName = fieldInfo.primaryKeyName;
    const itemIdOrIndex = (await inquirer_1.default.prompt({
        type: 'input',
        name: 'itemIdOrIndex',
        message: prompt !== null && prompt !== void 0 ? prompt : 'Enter id or index',
        default: DEFAULT_ALL_TEXT,
        validate: input => {
            return input === DEFAULT_ALL_TEXT ||
                cli_lib_1.convertToId(input, primaryKeyName, list)
                ? true
                : `Invalid id or index "${input}". Please enter an index or valid id.`;
        },
    })).itemIdOrIndex;
    const inputId = itemIdOrIndex == DEFAULT_ALL_TEXT ? itemIdOrIndex : cli_lib_1.convertToId(itemIdOrIndex, primaryKeyName, list);
    if (inputId === false) {
        throw Error(`unable to convert ${itemIdOrIndex} to id`);
    }
    return inputId;
}
class LogCatCommand extends cli_lib_1.SseCommand {
    async checkServerIdentity(cert) {
        const knownHubsPath = `${this.config.cacheDir}/known_hubs.json`;
        let knownHubs = {};
        try {
            knownHubs = JSON.parse(await fs_1.promises.readFile(knownHubsPath, 'utf-8'));
        }
        catch (error) {
            if (error.code !== 'ENOENT') {
                throw error;
            }
        }
        const known = knownHubs[this.authority];
        if (!known || known.fingerprint !== cert.fingerprint) {
            this.warn(`The authenticity of ${this.authority} can't be established. Certificate fingerprint is ${cert.fingerprint}`);
            const verified = (await inquirer_1.default.prompt({
                type: 'confirm',
                name: 'connect',
                message: 'Are you sure you want to continue connecting?',
                default: false,
            })).connect;
            if (!verified) {
                this.error('Hub verification failed.');
            }
            knownHubs[this.authority] = { hostname: this.authority, fingerprint: cert.fingerprint };
            await fs_1.promises.writeFile(knownHubsPath, JSON.stringify(knownHubs));
            this.warn(`Permanently added ${this.authority} to the list of known hubs.`);
        }
    }
    async chooseHubDrivers(commandLineDriverId, driversList) {
        const config = {
            itemName: 'driver',
            primaryKeyName: 'driver_id',
            sortKeyName: 'driver_name',
            listTableFieldDefinitions: driverFieldDefinitions,
        };
        const list = driversList !== null && driversList !== void 0 ? driversList : this.logClient.getDrivers();
        const preselectedId = await cli_lib_1.stringTranslateToId(config, commandLineDriverId, () => list);
        return cli_lib_1.selectGeneric(this, config, preselectedId, () => list, promptForDrivers);
    }
    async init() {
        var _a;
        await super.init();
        const { args, argv, flags } = this.parse(LogCatCommand);
        await super.setup(args, argv, flags);
        const hubIpAddress = (_a = flags['hub-address']) !== null && _a !== void 0 ? _a : await cli_lib_1.askForRequiredString('Enter hub IP address with optionally appended port number:');
        const [ipv4, port] = live_logging_1.parseIpAndPort(hubIpAddress);
        const liveLogPort = port !== null && port !== void 0 ? port : DEFAULT_LIVE_LOG_PORT;
        this.authority = `${ipv4}:${liveLogPort}`;
        this.logClient = new live_logging_1.LiveLogClient(this.authority, this.authenticator, this.checkServerIdentity.bind(this));
    }
    async run() {
        const installedDriversPromise = this.logClient.getDrivers();
        let sourceURL;
        if (this.flags.all) {
            sourceURL = await this.logClient.getLogSource();
        }
        else {
            const driverId = await this.chooseHubDrivers(this.args.driverId, installedDriversPromise);
            sourceURL = driverId == DEFAULT_ALL_TEXT ? await this.logClient.getLogSource() : await this.logClient.getLogSource(driverId);
        }
        // ensure this resolves before connecting to the event source
        const installedDrivers = await installedDriversPromise;
        cli_ux_1.default.action.start('connecting');
        await this.initSource(sourceURL);
        this.source.onopen = () => {
            if (installedDrivers.length === 0) {
                this.warn('No drivers currently installed.');
            }
            cli_ux_1.default.action.start('listening for logs');
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.source.onerror = (error) => {
            var _a;
            cli_ux_1.default.action.stop('failed');
            this.teardown();
            try {
                if ((error === null || error === void 0 ? void 0 : error.status) === 401 || (error === null || error === void 0 ? void 0 : error.status) === 403) {
                    this.error(`Unauthorized at ${this.authority}`);
                }
                live_logging_1.handleConnectionErrors(this.authority, error === null || error === void 0 ? void 0 : error.message);
                this.error((_a = error === null || error === void 0 ? void 0 : error.message) !== null && _a !== void 0 ? _a : error);
            }
            catch (error) {
                errors_1.handle(error);
            }
        };
        this.source.onmessage = (event) => {
            cli_lib_1.logEvent(event, live_logging_1.liveLogMessageFormatter);
        };
    }
}
exports.default = LogCatCommand;
LogCatCommand.description = 'stream logs from installed drivers';
LogCatCommand.flags = {
    ...cli_lib_1.SseCommand.flags,
    all: command_1.flags.boolean({
        char: 'a',
        description: 'stream from all installed drivers',
    }),
    'hub-address': command_1.flags.string({
        description: 'IPv4 address of hub with optionally appended port number',
    }),
};
LogCatCommand.args = [
    {
        name: 'driverId',
        description: 'a specific driver to stream logs from',
    },
];

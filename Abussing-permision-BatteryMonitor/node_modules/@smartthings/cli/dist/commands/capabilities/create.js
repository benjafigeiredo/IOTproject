"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const errors_1 = require("@oclif/errors");
const inquirer_1 = tslib_1.__importDefault(require("inquirer"));
const core_sdk_1 = require("@smartthings/core-sdk");
const cli_lib_1 = require("@smartthings/cli-lib");
const capabilities_1 = require("../capabilities");
const attributeAndCommandNamePattern = /^[a-z][a-zA-Z]{0,35}$/;
function commandOrAttributeNameValidator(input) {
    return !!attributeAndCommandNamePattern.exec(input)
        || 'Invalid attribute name; only letters are allowed and must start with a lowercase letter, max length 36';
}
function unitOfMeasureValidator(input) {
    return input.length < 25 ? true : 'The unit should be less than 25 characters';
}
class CapabilitiesCreateCommand extends cli_lib_1.APICommand {
    async run() {
        const { args, argv, flags } = this.parse(CapabilitiesCreateCommand);
        await super.setup(args, argv, flags);
        const params = {};
        if (flags.namespace) {
            params.namespace = flags.namespace;
        }
        const createCapability = async (_, capability) => {
            return this.client.capabilities.create(capability, params)
                .catch(error => {
                var _a;
                if (((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) == 403 && flags.namespace) {
                    throw new errors_1.CLIError('Unable to create capability under specified namespace. ' +
                        'Either the namespace does not exist or you do not have permission.');
                }
                throw error;
            });
        };
        await cli_lib_1.inputAndOutputItem(this, { buildTableOutput: data => capabilities_1.buildTableOutput(this.tableGenerator, data) }, createCapability, cli_lib_1.userInputProcessor(this));
    }
    addCommand(capability, name, command) {
        if (capability.commands === undefined) {
            capability.commands = {};
        }
        capability.commands[name] = command;
    }
    async promptAndAddSetter(capability, attributeName, attribute, type) {
        const addSetter = (await inquirer_1.default.prompt({
            type: 'confirm',
            name: 'addSetter',
            message: 'Add a setter command for this attribute?',
        })).addSetter;
        this.logger.debug(`promptAndAddSetter - addSetter = ${addSetter}`);
        if (addSetter) {
            // add setter command name to attribute and create the command, if applicable
            const commandName = `set${attributeName.replace(/^\w/, c => c.toUpperCase())}`;
            attribute.setter = commandName;
            const argument = {
                name: 'value',
                optional: false,
                schema: this.buildSchemaMatchingAttributeType(attribute, type),
            };
            const setterCommand = {
                name: commandName,
                arguments: [argument],
            };
            this.addCommand(capability, commandName, setterCommand);
        }
    }
    addBasicCommand(capability, attribute, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    commandName, type, value) {
        if (!attribute.enumCommands) {
            attribute.enumCommands = [];
        }
        attribute.enumCommands.push({ command: commandName, value });
        const command = {
            name: commandName,
            arguments: [{
                    name: 'value',
                    optional: false,
                    schema: this.buildSchemaMatchingAttributeType(attribute, type),
                }],
        };
        this.addCommand(capability, commandName, command);
    }
    async promptAndAddBasicCommands(capability, attribute, type) {
        let basicCommandName = '';
        const baseMessage = 'If you want to add a basic command, enter a ' +
            'command name now (or hit enter for none):';
        let message = `${baseMessage}\n(Basic commands are simple commands ` +
            'that set the attribute to a specific value.)';
        do {
            basicCommandName = (await inquirer_1.default.prompt({
                type: 'input',
                name: 'basicCommandName',
                message,
                validate: (input) => {
                    // empty string is allowed here because it ends basic command name input
                    return !input || commandOrAttributeNameValidator(input);
                },
            })).basicCommandName;
            message = baseMessage;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            let basicCommandValue = undefined;
            const minimum = attribute.schema.properties.value.minimum;
            const maximum = attribute.schema.properties.value.maximum;
            const maxLength = attribute.schema.properties.value.maxLength;
            if (basicCommandName) {
                // TODO: This switch (/if/else/else) should be handled in a
                // more generic/object oriented way
                if (type === "integer" /* INTEGER */ || type === "number" /* NUMBER */) {
                    basicCommandValue = parseInt((await inquirer_1.default.prompt({
                        type: 'input',
                        name: 'basicCommandValue',
                        message: 'Command Value: ',
                        validate: (input) => {
                            if (isNaN(input)) {
                                return 'Please enter a numeric value';
                            }
                            if (typeof minimum === 'number' && parseInt(input) < minimum) {
                                return 'Number must be greater than or equal to minimum.';
                            }
                            if (typeof maximum === 'number' && parseInt(input) > maximum) {
                                return 'Number must be less than or equal to maximum value.';
                            }
                            return true;
                        },
                    })).basicCommandValue);
                }
                else if (type === "string" /* STRING */) {
                    basicCommandValue = (await inquirer_1.default.prompt({
                        type: 'input',
                        name: 'basicCommandValue',
                        message: 'Command Value: ',
                        validate: (input) => {
                            if (typeof maxLength === 'number' && input.length > maxLength) {
                                return 'String cannot be greater than maximum length.';
                            }
                            return true;
                        },
                    })).basicCommandValue;
                }
                else if (type === "boolean" /* BOOLEAN */) {
                    basicCommandValue = (await inquirer_1.default.prompt({
                        type: 'list',
                        name: 'basicCommandValue',
                        message: 'Command Value: ',
                        // choices must be strings as per inquirer documentation
                        choices: ['True', 'False'],
                    })).basicCommandValue;
                }
                else {
                    this.logger.error('invalid state in promptAndAddBasicCommands');
                }
                this.addBasicCommand(capability, attribute, basicCommandName, type, basicCommandValue);
            }
        } while (basicCommandName);
    }
    async promptForType(message) {
        return (await inquirer_1.default.prompt({
            type: 'list',
            name: 'type',
            message: `Select an ${message} type:`,
            choices: ["integer" /* INTEGER */, "number" /* NUMBER */, "string" /* STRING */, "boolean" /* BOOLEAN */],
        })).type;
    }
    async promptForAttributeName() {
        return (await inquirer_1.default.prompt({
            type: 'input',
            name: 'attributeName',
            message: 'Attribute Name: ',
            validate: commandOrAttributeNameValidator,
        })).attributeName;
    }
    async promptForUnitOfMeasure() {
        return (await inquirer_1.default.prompt({
            type: 'input',
            name: 'unitOfMeasure',
            message: 'Unit of measure (default: none): ',
            validate: unitOfMeasureValidator,
        })).unitOfMeasure;
    }
    async promptAndAddAttribute(capability) {
        let name = await this.promptForAttributeName();
        let userAcknowledgesNoSetter = false;
        while (name.length > 33 && !userAcknowledgesNoSetter) {
            const answer = (await inquirer_1.default.prompt({
                type: 'list',
                name: 'answer',
                message: `Attribute Name ${name} is too long to make a setter.`,
                choices: [
                    { name: 'Enter a shorter name (max 33 characters)', value: 'shorter ' },
                    { name: 'I won\'t need a setter', value: 'noSetter' },
                ],
            })).answer;
            if (answer === 'noSetter') {
                userAcknowledgesNoSetter = true;
            }
            else {
                name = await this.promptForAttributeName();
            }
        }
        const type = await this.promptForType('attribute');
        const attribute = {
            schema: {
                type: 'object',
                properties: {
                    value: {
                        type,
                    },
                },
                additionalProperties: false,
                required: [core_sdk_1.CapabilitySchemaPropertyName.VALUE],
            },
        };
        if (type === "integer" /* INTEGER */ || type === "number" /* NUMBER */) {
            const minValue = (await inquirer_1.default.prompt({
                type: 'input',
                name: 'minValue',
                message: 'Minimum value (default: no minimum): ',
                validate: (input) => {
                    return input.length === 0 || !isNaN(input) || 'Please enter a numeric value';
                },
            })).minValue;
            if (minValue) {
                attribute.schema.properties.value.minimum = parseInt(minValue);
            }
            const maxValue = (await inquirer_1.default.prompt({
                type: 'input',
                name: 'maxValue',
                message: 'Maximum value (default: no maximum): ',
                validate: (input) => {
                    if (input.length === 0) {
                        return true;
                    }
                    if (isNaN(input)) {
                        return 'Please enter a numeric value';
                    }
                    return minValue === undefined
                        || parseInt(input) > parseInt(minValue)
                        || 'Maximum value must be greater than minimum value.';
                },
            })).maxValue;
            if (maxValue) {
                attribute.schema.properties.value.maximum = parseInt(maxValue);
            }
            const unit = await this.promptForUnitOfMeasure();
            if (unit) {
                // Note: we don't support multiple units here because we want to move toward using a single unit
                // of measure in capabilities
                attribute.schema.properties.unit = {
                    type: 'string',
                    enum: [unit],
                    default: unit,
                };
            }
        }
        else if (type === "string" /* STRING */) {
            // TODO: min length also ???
            const maxLength = (await inquirer_1.default.prompt({
                type: 'input',
                name: 'maxLength',
                message: 'Maximum length (default: no max length): ',
                validate: (input) => {
                    return input.length === 0 || !isNaN(input) || 'Please enter a numeric value';
                },
            })).maxLength;
            if (maxLength) {
                attribute.schema.properties.value.maxLength = parseInt(maxLength);
            }
        }
        if (!userAcknowledgesNoSetter) {
            await this.promptAndAddSetter(capability, name, attribute, type);
        }
        await this.promptAndAddBasicCommands(capability, attribute, type);
        if (capability.attributes === undefined) {
            capability.attributes = {};
        }
        capability.attributes[name] = attribute;
    }
    buildSchemaMatchingAttributeType(attribute, type) {
        const retVal = {
            type,
        };
        if (attribute.schema.properties.value.minimum !== undefined) {
            retVal.minimum = attribute.schema.properties.value.minimum;
        }
        if (attribute.schema.properties.value.maximum !== undefined) {
            retVal.maximum = attribute.schema.properties.value.maximum;
        }
        if (attribute.schema.properties.value.maxLength !== undefined) {
            retVal.maxLength = attribute.schema.properties.value.maxLength;
        }
        return retVal;
    }
    async promptAndAddCommand(capability) {
        var _a, _b;
        const name = (await inquirer_1.default.prompt({
            type: 'input',
            name: 'commandName',
            message: 'Command Name: ',
            validate: commandOrAttributeNameValidator,
        })).commandName;
        const command = {
            name,
            arguments: [],
        };
        let argumentName = '';
        do {
            argumentName = (await inquirer_1.default.prompt({
                type: 'input',
                name: 'argumentName',
                message: 'If you want to add argument, enter a name for it now (enter to finish): ',
            })).argumentName;
            if (argumentName) {
                const type = await this.promptForType('argument');
                const optional = (await inquirer_1.default.prompt({
                    type: 'confirm',
                    name: 'optionalArgument',
                    message: 'Is this argument optional?',
                })).optionalArgument;
                const argument = {
                    name: argumentName,
                    optional,
                    schema: {
                        type,
                    },
                };
                (_a = command.arguments) === null || _a === void 0 ? void 0 : _a.push(argument);
            }
        } while (argumentName);
        if (((_b = command.arguments) === null || _b === void 0 ? void 0 : _b.length) === 0) {
            delete command.arguments;
        }
        this.addCommand(capability, name, command);
    }
    // TODO: throughout this Q&A session there seldom options to cancel input
    // choices without starting completely over. We need to look at fixing this.
    // TODO: also, this process needs more up-front validation
    async getInputFromUser() {
        const name = (await inquirer_1.default.prompt({
            type: 'input',
            name: 'capabilityName',
            message: 'Capability Name:',
            validate: (input) => {
                return new RegExp('^[a-zA-Z0-9][a-zA-Z0-9 ]{1,35}$').test(input) || 'Invalid capability name';
            },
        })).capabilityName;
        const capability = {
            name,
        };
        let action;
        let choices = ["Add an attribute" /* ADD_ATTRIBUTE */, "Add a command" /* ADD_COMMAND */];
        do {
            action = (await inquirer_1.default.prompt({
                type: 'list',
                name: 'action',
                message: 'Select an action...',
                choices,
            })).action;
            if (action === "Add an attribute" /* ADD_ATTRIBUTE */) {
                await this.promptAndAddAttribute(capability);
            }
            else if (action === "Add a command" /* ADD_COMMAND */) {
                await this.promptAndAddCommand(capability);
            }
            choices = ["Add an attribute" /* ADD_ATTRIBUTE */, "Add a command" /* ADD_COMMAND */, "Finish & Create" /* FINISH */];
        } while (action !== "Finish & Create" /* FINISH */);
        return capability;
    }
}
exports.default = CapabilitiesCreateCommand;
CapabilitiesCreateCommand.description = 'create a capability for a user';
CapabilitiesCreateCommand.flags = {
    ...cli_lib_1.APICommand.flags,
    ...cli_lib_1.inputAndOutputItem.flags,
    namespace: command_1.flags.string({
        char: 'n',
        description: 'the namespace to create the capability under',
    }),
};
